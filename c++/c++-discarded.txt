>>>库文件实际上是所有函数逻辑打包后的文件

>>>静态库文件 : 包含了全部的包括调用函数的代码 window: .lib , linux: .a , 因为代码比较全所以比较大

>>>动态库文件 : 只包含本身代码的逻辑, 不包含其调用的其他库文件中函数的逻辑代码 , windows: .dll , linux: .so

>>>关于常量的定义 : c++中的 const int N = 100其实就是c里面的#define N 100

>>>重定向输入流 : 使用文件内容作为程序的输入
```
#这里使用abc.txt中的内容作为程序test.exe的输入, 然后将程序执行结果输出到res.txt中
>test.exe < abc.txt > res.txt
```

>>>对于程序中的浮点数 : 因为浮点数在内存中都是非精度存储 , 所以判断浮点数是否相等一律使用 fabs(a,b)<1e-05

>>>c++中的两种字符串 : 
--->c-string : 
- c语言中的字符串 , 本质是字符数组(常量字符指针)
- 结束符为 '\0'
- 实际长度为字符串长度+1
- 保存位置 : 栈 -> 全局数据区
--->string类 : 
- c++中的字符串类 , 包含各种内置方法

>>> c++项目中方法分文件写：
1. 创建外部方法的头文件， 其中写方法的声明
2. 创建外部方法的源文件， 其中引用包含该方法声明的头文件， 然后写方法的源代码
3. 在要使用该方法的cpp文件中使用“”引用包含声明的头文件， 然后直接使用方法即可
* 建议把函数定义写到h文件中, 把函数实现写到cpp中, cpp文件可打包为库文件, 从而达到隐藏函数实现的效果, 别人在调用这个库文件时, 只要引入对应的h文件, 然后就可以知道函数的定义并且可以使用, 但是不知道源码.

>>> 指针变量的本质是 unsigned int (4个字节)
>>> 32位操作系统中, 指针变量占用4个字节, 64位操作系统中, 指针变量占用8个字节

>>> 空指针: 指向内存地址为0的指针变量 , 内存地址为0~255的内存为系统占用内存,不允许用户访问
>>> 空指针定义 : int *p = NULL; 用于初始化指针变量

>>> 野指针: 指向非法内存空间的指针变量 , 比如 int *p = (int *)0x0011;

>>> 常量指针 : const int * p = &a;  指针的指向可以修改,指向的值不可以修改 (指向常量的指针)
>>> 指针常量: int * const p = &a; 本身是个常量的指针, 指向不可以修改,指向的值可以修改
>>> 常量指针常量 : const int * const p = &a; 本身是个常量, 而且指向的值也不能修改的指针, 指向不能改, 指向的值也不能改

>>> 结构体指针 : student * p = s; 使用指针访问成员变量: p->name;

>>> 函数指针 : 指向函数的指针 
==> 函数指针指向的函数必须和其类型相同 , 函数的类型为 : 把函数的定义中的函数名去掉 , 函数指针的类型 : 把函数指针中的指针名去掉
==> 函数指针的定义 : <返回类型>  (* 指针名)(函数的参数列表) : 如 int (*p) (int);
```
//定义一个函数
int g(int);
//定义指向该函数的指针
int (*gp)(int)=g;
```
==> 使用函数作为形参: 
```
//定义一个函数 , 参数列表为 int类型的指针, (返回int类型的)(参数列表为int的)函数地址(即函数名)
void f(int*,int(*)(int));
```

>>> 将函数的形参设置为指针, 可以防止因为复制数据而占用过多的内存空间, 同时为了防止在调用函数的过程中对原数据进行误操作, 可以使用const 修饰形参指针变量

>>> system("pause"); 是显示 按任意键退出...

>>> system("cls"); 清屏

>>> 由于局部变量保存在栈区, 由编译器控制其生命周期, 所以不能将其地址作为函数返回值, 会使得这个返回的地址是无意义的. (编译器为防止这个问题,会保存一次这个地址上的值)

>>> 使用new在堆区开辟内存: int * p = new int(10);  开辟int大小的内存,并且赋初值为10,最后返回这段内存的地址

>>> 使用delete 释放堆区开辟的内存: delete p;   释放开辟的数组空间: delete[] arr;

>>> 引用: 给变量起别名.  int a = 10; int &b = a; 相当于a的别名是b, 对b的操作等同于对a的操作
---> 创建引用时, 必须赋初值, 而且初始化之后, 不能再改变引用的指向. 
---> int a = 10; 
---> int &b = a; //创建引用b指向a
---> int c = 20;
---> b = c; //没有改变b引用的指向, 实际上只是改变的b的值,也就是改变了a的值

>>> 使用引用进行地址传参 -- 相当于使用指针进行参数传递
---> 原函数中: swap(a,b);
---> 调用的函数: void swap(int &a, int &b){ int tmp = a; a=b; b=temp; }

>>> 使用引用类型作为函数的返回值(  eg: int& test(){xxx}  ): 相当于返回某个变量本身(不要返回局部变量), 对这个返回值做的操作相当于对这个变量进行操作.
---> 返回引用类型的函数的调用可以作为表达式的左值(表达式左边), 相当于对返回的变量进行操作.

>>> 引用的内部实现是指针常量: int &p = a; --> int * const p = &a; 所以引用的指向不可以修改,但是值可以修改.
>>> 对引用的赋值操作, 编译器自动转化. p = 10; --> *p = 10;

>>> 使用常量引用防止引用指向的变量被误修改: void print(const int &p){ xxx } -> 该函数中对引用p只能进行读操作,防止了误修改.(原理同常量指针的使用)

>>> 函数的默认参数: void fun( int a, int b = 10, int c = 20 ){ xxx }
---> 默认参数必须在形参列表的末尾
---> 如果是先声明后定义的函数, 在声明和实现中只能有一个指定默认参数

>>> 函数的占位参数: void fun( int a , int = 10 ){   }
---> 如果占位参数没有默认值, 则调用函数时必须传这个参数. 同时占位参数可以有默认值.

>>> 函数的重载: 相同的函数名, 不同的参数(重载)
---> 加const的引用形参和不加const的引用形参可以作为函数参数重载( const int &a 和 int &a, 调用分别为 10 和 a )
---> 使用默认函数时重载要注意不能因为默认参数而引起冲突

>>> 分文件编写类
---> 新建类的头文件 head.h
---> 在类的头文件中 写 #pragma once (防止多次包含)
---> 在类的头文件写 #include <iostream>
---> 在类的头文件写 using namespace std;
---> 在类的头文件中写类的实现 , 其中成员方法只写声明部分
---> 创建类的源文件 , 在其中包含类的头文件 #include "head.h"
---> 在源文件中写直接写各个类成员方法的实现, 其中在每个方法名的前面加上   类属:: (类属为类的名字)
---> 在要使用类的文件中引入类的头文件

>>> 类的构造函数和解构函数: Person(){ xxx } 和 ~Person(){ xxx }  解构函数不可加参数, 因此不可重载
---> 拷贝构造函数: Person( const Person &p ){ 使用p进行初始化操作... } (调用该构造函数实现拷贝)
---> 新建实例的方法:
---> √括号法: 1. Person p;(默认调用无参) 2.Person p1(10); (默认调用有参) 3.Person p2(p); (默认调用拷贝)
---> 显示法(java法无new): 1. Person p;(默认调用无参) 2.Person p1 = Person(10); (调用有参) 3.Person p2 = Person(p); (调用拷贝)
---> 	匿名对象: Person(10); 编译器在该行代码运行结束就解构该对象
---> 	不要使用拷贝构造初始化匿名对象: Person(p); 编译器会解析为 Person p; 认为是对p的重定义而报错.
---> 隐式调用法: 1. Person p = 10; (调用有一个int参数的构造)  2. Person p = p1; (调用拷贝构造)

>>> 在值传参的函数调用时, 自动调用该参数类型的拷贝构造函数
---> 如果人为在拷贝函数中修改相关数据, 则按照自定义中修改的属性来修改,其余的保持拷贝(同react中的setState()). 否则执行默认的完全拷贝函数
>>> 在值返回对象的函数中, 执行到返回那句代码时, 会调用拷贝函数, 返回一个拷贝的对象.

>>>编译器默认提供拷贝构造函数

>>>深拷贝 与 浅拷贝 (如果构造函数有在堆区进行申请内存空间的操作, 使用深拷贝方法)
---> 如果对象中包含指针成员, 在构造函数中对指针进行在堆区的内存申请, 则在解构函数中应当释放在堆区申请的内存.
---> 编译器对对象的拷贝为浅拷贝, 即 直接拷贝每个成员属性的值.
        如果对象包含指针成员变量, 则浅拷贝会拷贝指针上地址的值, 从而使编译器在对不同的对象实例进行解构时会因为堆区内存被重复释放而报错.
        为了避免浅拷贝带来的重复解构问题, 应当重写解构函数对指针成员变量进行深拷贝.(重新申请堆区内存)

>>> 初始化列表( 类的构造函数 ): Person(int a , int b, int c): m_A(a), m_B(b), m_C(c) { } , 提供单个参数的有参构造函数, 在进行构造时将参数赋值给成员属性

>>> 静态成员函数: static void fun(){ xxx }  (静态成员函数只能访问静态成员变量)
---> 调用: 1. Person p;  p.fun();   2. Person::fun();(静态成员变量的访问 Person::m_A = 10;)
---> 静态成员函数也可设置访问权限(public, private, protected)

>>> 没有任何属性类的对象占1个字节

>>> 只有类上的非静态成员变量跟类的对象存储到一块 ( 其他的都存到别的地方去了 )

>>> this: 对象指针 ( 实质是指针常量,不可修改指向, 使用: this->age )
---> java中的指针, 是实例本身, 并不是指针类型

>>> 链式编程的实现: 在函数中返回对象类型的引用 ( 如 Person & )

>>> 对象的空指针可以访问类的成员函数(Person *p = NULL), 但如果调用的函数中涉及到成员变量, 就会因指针为空而报错. 
        为了防止空指针的非法调用, 在成员函数中加: if( this == NULL ) return;

>>> 常函数( const 函数 ): void fun() const { ... }  在常函数中不能修改除了mutable类型的成员变量
---> 内部实现: void fun() const { ... } ==> const Person * const this; ( 设置this为常量指针常量,故不可修改其他成员变量 )

>>> 常对象: const Person p; 对于该对象, 除了mutable属性外都不可修改
---> 常对象只能调用常函数( 因为普通函数可以修改普通属性, 如果能调用普通函数, 则意味着常对象能修改普通属性, 则与其本身特性矛盾 )

>>> 特殊变量: mutable int a; 在常函数中可以修改, 在常对象中也可以修改.

>>> new方法创建对象是在堆区开辟内存: Building builging = new Building;

>>> 类的声明: class Person;

>>> 类的方法在类外实现: 1. 类内写声明. 2. 类外写实现 
---> 实现要加从属域 void Person::fun(){ ... }

>>> 友元( 可以访问类内private的元素 )
---> 全局函数为友元: class Person{  friend void fun( );  public: ...  private: ...  }   写友元定义时不需写权限范围
---> 类作为友元: friend class GoodGay;
---> 类中的成员函数做友元: friend void GoodGay::visit( );

>>> 运算符重载 ( 使用原有的运算符对自定义的类对象进行操作 )
---> + 的重载: 
----> ① 成员函数重载 class Person{ public: Person operator+( const Person &p ){ ... } }
             实现Person + Person 
             使用:  Person c = a.operator+(b) 或 Person c = a + b;( a,b都是Person )
----> ② 使用全局函数重载 Person operator+( Person a, Person b ){ ... }
             使用:  Person c = operator+(a,b) 或 Person c = a + b;( a,b都是Person )
---> 重载函数也可根据参数重载: 实现如 Person + Int , Person + Person + Person 等
---> 内置数据类型的默认运算操作不可重载
 
---> <<(左移运算符)的重载: ( 使用cout对自定义对象的自定义输出 ) ( 左移运算实际上属于"算" )
----> 只能全局函数重载  ostream & operator<<( ostream & o, Person &p ){ o<< p.m_age << "," << p.m_name;  return o;}
----> cout是ostream类型的对象
----> 函数实质是: operator<<(cout, p)
----> 返回ostream &实现链式编程

---> ++(递增运算符)的重载  ~~> reaload++.md

---> = 赋值运算符的重载 ( 使用赋值运算符的重载实现对自定义对象的深拷贝 )  ~~> reload=.md

---> == 和 != 关系运算符的重载 bool operator==(Person & p){ ... } 和 bool operator!=(Person & p){ ... }

---> () (函数调用运算符) 的重载 , 使得类对象可以像函数一样调用并且返回值, 也叫 仿函数
----> void operator() ( ... ){ ... } (设类名为MyAdd , 该重载函数为成员函数)
----> 使用: 
	① 新建类对象调用 MyAdd myadd;    myadd( ... );
	② 使用匿名对象调用 MyAdd()( ... )  ( MyAdd() 相当于创建了一个匿名对象 )

>>> 类的继承: class Child : public Parent{ ... } 
---> 继承方式
----> ①public : public 继承为 public, protected 继承为 protected
----> ②protected: public 和 protected 都继承为 protected
----> ③private: public 和 protected 都继承为 private
---> 在继承过程中, 父类的非静态成员变量全部被继承下来, 只是编译器做了处理使得不同的数据类型在子类中有不同的访问权限
       (eg: 父类中3个属性, 子类中1个属性, 则子类的长度为4个属性)

>>> 使用visual studio自带的开发人员命令行工具 查看类的结构
①打开该工具
②cd 切换到cpp源文件目录下
③dir 查看目录下的文件
④cl /d1 reportSingleClassLayoutXXX "cpp的文件名"  ( XXX是源文件中包含的要查看的类的名字 )
⑤命令行会列出类的结构

>>> 继承中的构造和解构的顺序 ( 栈 )
父类构造
子类构造
子类解构
父类解构

>>> 继承中的同名成员
访问 子类中的属性 , 直接访问 s.m_A;
访问 父类中的属性 , 加上从属域访问 s.Base::m_A;
访问 子类中的函数 , 直接访问 s.fun();
访问 父类中的函数 , 加上从属域访问 s.Base::fun();
---> 父类中的所有同名重载函数, 都需要加从属域来访问

>>> 继承中的同名静态成员
属性: ①通过对象访问 s.m_A; 和 s.Base::m_A;  ( 访问父类中的同名属性要加从属域 )
        ②通过类名直接访问 Son::m_A; 和 Son::Base::m_A; ( 访问父类中的同名属性要加从属域 )
函数: ①通过对象访问 s.fun(); 和 s.Base::fun(); 
        ②通过类名直接访问 Son::fun(); 和 Son::Base::fun();
---> 父类中的所有同名重载函数, 都需要加从属域来访问



