###### 常规匹配

[abc] 匹配方括号中的其中之一

[^abc] 匹配非方括号中的任意一个

[a-z] [A-Z] [0-9] 匹配a-z，A-Z，0-9中的某一个

. 匹配任意非 \r \n 的字符

\s 匹配空白符号

\S 匹配非空白符号

\w 匹配所有数字字母下划线，等同于[a-zA-Z0-9_] 

\d 匹配数字

\t 匹配一个制表符

\. 匹配除了换行符 \n 之外的任何



###### 匹配特殊

^ 表示开头

$ 表示结尾

[u4e00-u9fa5] 字母数字下划线以及汉字



###### 限定个数

\* 匹配前面的字符零次到多次，等同于 {0,}

\+ 匹配前面的字符一次到多次，等同于{1,}

? 匹配前面的字符零次或一次，等同于{0,1}

{n} 匹配前面的字符 n 次

{n,} 匹配前面的字符 n 到无数次

{n,m} 匹配前面的字符 n 到 m 次，包含 n 和 m



###### 关闭贪婪

\* 和 \+ 都是尽可能多地匹配更多的贪婪方式

后面加?表示非贪婪方式匹配 `*?` 和 `+? `

 

###### 条件匹配

`(?=xxx)`  查找后面是xxx的内容，匹配到的是前面的部分

*   `/gle(?=\sR)/.exec(str)` 这个就是查后面是 `空格R` 的字符串 `gle`

`(?<=xxx)`  查找前面是xxx的内容，匹配到的是后面的部分

*   `/(?<=\sR)gle/.exec(str)` 这个就是查后面是 `空格R` 的字符串 `gle`

`(?!xxx)`  查找后面不是xxx的内容，匹配到的是前面的部分

*   `/gle(?!\sR)/.exec(str)` 这个就是查后面不是 `空格R` 的字符串 `gle`

`(?<!xxx)`  查找前面不是xxx的内容，匹配到的是后面的部分

*   `/(?<!\sR)gle/.exec(str)` 这个就是查前面不是 `空格R` 的字符串 `gle`





###### 反向正则匹配

默认不支持

但是可以

*   先翻转字符串，然后匹配
*   或者使用支持反向匹配的正则表达式引擎