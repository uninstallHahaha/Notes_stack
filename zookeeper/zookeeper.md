##### 分布式系统的CAP理论

C: consistency 一致性, 要求各个节点每时每刻都保持数据一致

A: Avalibility 可用性, 系统要求一直能够提供正常有效的服务

P: Partition Tolerance 分区容错性, 某个节点出现错误时, 整个系统仍然能对外正常提供服务

***P*** 是一定要满足的, 因为如果某个节点除了故障系统就瘫痪, 那么整这个分布式还有什么意义, 还不如直接单机运行

而且, CAP不同三个同时满足, 因此就必须从 C 或者 A 中舍弃一点





##### zookeeper 

​	用于存放分布式系统中的共享数据, 它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等

​	zookeeper满足的是CP, 不能确保总是可以正常访问, 但是保证数据绝对给你整对了

​	zookeeper学术上来说是 ***分布式协调系统*** , 以集群的方式给分布式系统提供统一的数据服务, 而且要从外边看像是一台单机, 它的优势就在于能够很快地完成数据的同步, 作为一个成熟的程序, 其他框架也就不自己再造轮子, 直接就使用zk, 因此zk才会流行起来





###### 读写分离?

​	分为leader, fllower, observer节点, 只有leader执行写操作, 其他节点提供读服务

###### session?

​	客户端与服务端建立连接时创建session, 定时心跳检测连接状态, 并且客户端可以watch节点变换, 当对应节点发生变化时, 服务端通知客户端, 然后客户端再读取新的值

###### 临时与永久节点?

​	可以选择创建临时或者永久节点, 临时节点在断开session连接时就自动删除

###### 节点存储?

​	数据节点按照文件的组织方式存储, /xxx/yyy/zzz

###### 数据发布与订阅?

​	发布者在指定节点添加信息, 订阅者watch这些节点实时获取到最新信息

###### 命名管理?

​	可以用作分布式命名管理系统, 使用自增值的节点作为分布式数据库记录的id, 可保证分布式数据库系统id不重复

###### 监听机制?

​	与zookeeper建立连接的会话可以选择监听感兴趣的节点的事件, 当发生这些事件时, 会话收到通知

###### 分布式锁?

​	请求临界数据时向zookeeper中添加临时编号节点, 然后检查是否为当前最小节点, 是则认为拿到了锁, 否则监听前一个编号节点的删除事件, 直至收到通知, 才代表获得了锁

###### 注册中心?

​	生产者在上面注册节点, 消费者从上面查看可用节点进行访问

###### 配置中心?

​	将分布式服务要用到的公共配置放到其节点上, 各个服务从上面取配置使用, 这样在配置需要修改时只需要修改zookeeper上的节点值即可





###### 分布式paxos算法

​	<span style='color:cyan;'>用于保证分布式系统中, 各个节点的数据一致性问题</span>

​	在该算法中, 分为 提议者, 接收者, 学习者 三种角色

***提议者***: 其实就是客户端, 用来向分布式系统中发送数据

***接收者***: 其实就是分布式系统的节点, 它们不仅要接收提议者的数据, 还要保证每个节点的数据都一致

***学习者***: 用来做数据冗余, 可以看作是分布式系统中的 slave

​	因为要保证所有节点的数据一致, 所以提议者每次有新的数据时都要向所有的接收者发送一份.

​	首先假设接收者一旦接收到提议者的数据就保存下来, 如果此时有多个提议者在发送数据, 而且存在网络波动, 那么它们的数据到达的时间将是乱序的, 那么肯定会造成各个接收者上最后保存下来的数据不尽相同, 来自于各个提议者, 此时分布式系统就处于数据不一致的境地.

​	paxos算法, 为了解决分布式系统各个节点的数据一致性问题

​	提议者向接收者写数据的过程分为两个阶段, ***准备*** 和 ***接收***

​	<span style='color:cyan;'>准备阶段</span>

​	各个提议者都产生一个编号发给各个接收者, 各个接收者都选最大的编号给予响应, 因为编号越大代表数据越新

​	<span style='color:cyan;'>接收阶段</span>

​	发送了小编号的提议者自然没有收到接收者的响应, 那么瞬间就明白了自己的数据不是最新的, 也就是本次写数据失败. 

​	而对于发送了最大编号的提议者, 它将会收到大部分接收者的响应, 也就是收到大部分节点说 "大, 你这个大, 我们存你的数", 然后这个最大编号提议者就把自己的值发送给所有的接收者 

​	接收者一看, 是这个最大编号对应的值, 就保存下来, 此时所有提议者节点都保存了最新的值 , 它们的数据是一致的 

​	最后学习者也默默地备份下这个值, 如果此时接收者中少数还没更新到最新值, 就由学习者发给它最新的值保存下来.

​	paxos算法能够保持所有节点数据一致性的本质在于, 第一次的响应是用来确定最后要用哪个值, 然后没说上话的提议者一看不是自己就不再写数据了, 第二阶段就只剩下被选中的提议者, 相当于它干掉了其他提议者, 最后把自己的值写到各个节点.

​	分成两个步骤的目的就是单独用第一个步骤确定最后要的, 到第二步时才真正进行写数据



###### zab协议

***写操作***

​	leader 节点用来执行写操作,  fllower节点用来执行读操作, 客户端随便连接一个节点, 如果是读操作那么直接进行, 如果是写操作那么转发给leader节点执行.

​	leader节点首先将写操作广播给其他fllower节点, fllower 节点收到消息后开始写事务, 然后返回给 leader 节点确认写消息, leader 收到大部分确认写操作后, 认定为本次写操作成功, 也就是 "我的小弟们都同意了"

​	然后再次广播提交写事务, 各个 fllower 收到后就提交写事务, 完成本次写操作的数据更新

***leader崩溃时***

​	选举新的leader , 然后其他 fllower 与新 leader 进行数据同步, 当大部分节点都完成了数据同步时, 认为系统恢复正常

***保证消息有序***

​	每个在集群中发送的广播都会带上一个编号zxid, 节点接收到编号后按照编号顺序执行

