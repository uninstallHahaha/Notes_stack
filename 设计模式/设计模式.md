###### 建造者模式--套餐

对于一个复杂对象, 该对象由多个小的组件组成, 而创建复杂对象的组成又是多变的, 此时可以将各个小的组件抽离为统一的子组件, 然后使用建造者对象根据需求创建不同的复杂对象

比如: 

点餐的时候点的是套餐, 实际上其本质就是 汉堡, 可乐, 薯条, 炸鸡 组成的不同组合, 

那么我们就可以把这些单品抽离为统一的 Item , 

然后定义套餐类 Meal, 其中维护一个 Item数组, 用来保存当前套餐包含的单品, 

最后, 定义 MealBuilder类, 提供不同的方法用来快捷地创建不同的 套餐, 

使用这种方式, 如果以后再想添加新的套餐, 只需要在 MealBuilder 类中添加对应的用来创建 Meal 实例的方法即可



###### 适配器模式--接口转换

 举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 

 **意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 

 **主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。 





###### 过滤器模式--不同的过滤器

创建过滤器接口, 包含过滤方法

创建多个过滤接口实现类, 在其中维护 被过滤对象数组, 接受一个被过滤对象数组, 使用不同的过滤规则保存过滤结果到内部数组, 最后返回

总的来说

`过滤器接口`

`过滤器接口实现类1` `过滤器接口实现类2` `过滤器接口实现类3`

`过滤结果数组 = 过滤器接口实现类实例.过滤方法(被过滤对象数组)`





###### 策略模式--装载不同策略

适合的场景: 对于一个方法有多种实现, 那么只需要更换策略实例部分即可, 而不是使用大量的 if else

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法

1. 一个包含策略方法的接口

   <img src="设计模式.assets/1637048048925.png" alt="1637048048925" style="zoom:67%;" />

2. 几个实现该策略接口的类, 对于指定的方法有不同的实现

   <img src="设计模式.assets/1637048058250.png" alt="1637048058250" style="zoom:67%;" />

3. 一个context类, 包含策略类型的字段, 通过向构造函数中传递不同的策略实现类, 保存不同的策略

   <img src="设计模式.assets/1637048070101.png" alt="1637048070101" style="zoom:67%;" />





###### [门面模式](https://www.runoob.com/w3cnote/facade-pattern-3.html)--提供统一入口

对于一个有多个模块的系统, 用户需要根据不同的需求访问这些个模块, 此时用户需要处理的逻辑就是复杂的

此时可以创建一个单独的 门面实例, 整合了系统中所有模块的接口, 那么用户只需要拿着自己的需求跟门面类打交道即可, 极大地方便了用户的处理逻辑

例如, 医院系统, 包含多个子系统, 此时可以创建一个 接待员的角色, 用户只需要跟接待员交互即可, 实际的操作由接待员分发给各个子系统

<img src="设计模式.assets/1637071033396.png" alt="1637071033396" style="zoom:80%;" />







###### 享元模式--事先缓存

在程序运行初期一次性将要使用到的对象创建缓存到 hashmap 中, java 的基本类型缓存池就是这种机制







###### 责任链模式--层层传递

多个类实现同一个接口, 包含同样的处理方法, 并且都保存下一个节点, 最后使用多个实现类节点组成链式结构, 链首接收请求, 不能处理时则传递给后面的节点, 层层传递直至链尾

js中的事件冒泡机制就是典型的责任链模式





###### 命令模式--不同的命令不同的逻辑

优势在于对多种逻辑进行解耦, 可以独立地执行某些逻辑

要点是将命令抽象为不同的实现类

1. 创建多个实现了命令接口的实现类

2. 创建可维护命令类型数组的命令调用类, 其中提供添加命令方法, 执行命令方法

   添加命令方法会将命令添加到内部命令数组

   执行命令方法会执行命令数组中所有命令并清空该数组

3. 使用时首先创建命令调用类实例, 然后调用添加命令方法, 最后调用执行命令方法