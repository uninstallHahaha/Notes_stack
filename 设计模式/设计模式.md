###### 建造者模式

对于一个复杂对象, 该对象由多个小的组件组成, 而创建复杂对象的组成又是多变的, 此时可以将各个小的组件抽离为统一的子组件, 然后使用建造者对象根据需求创建不同的复杂对象

比如: 

点餐的时候点的是套餐, 实际上其本质就是 汉堡, 可乐, 薯条, 炸鸡 组成的不同组合, 

那么我们就可以把这些单品抽离为统一的 Item , 

然后定义套餐类 Meal, 其中维护一个 Item数组, 用来保存当前套餐包含的单品, 

最后, 定义 MealBuilder类, 提供不同的方法用来快捷地创建不同的 套餐, 

使用这种方式, 如果以后再想添加新的套餐, 只需要在 MealBuilder 类中添加对应的用来创建 Meal 实例的方法即可



###### 适配器模式

 举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 

 **意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 

 **主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。 





###### 过滤器模式

创建过滤器接口, 包含过滤方法

创建多个过滤接口实现类, 在其中维护 被过滤对象数组, 接受一个被过滤对象数组, 使用不同的过滤规则保存过滤结果到内部数组, 最后返回

总的来说

`过滤器接口`

`过滤器接口实现类1` `过滤器接口实现类2` `过滤器接口实现类3`

`过滤结果数组 = 过滤器接口实现类实例.过滤方法(被过滤对象数组)`





###### 策略模式

适合的场景: 对于一个方法有多种实现, 那么只需要更换策略实例部分即可, 而不是使用大量的 if else

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法

1. 一个包含策略方法的接口

   <img src="设计模式.assets/1637048048925.png" alt="1637048048925" style="zoom:67%;" />

2. 几个实现该策略接口的类, 对于指定的方法有不同的实现

   <img src="设计模式.assets/1637048058250.png" alt="1637048058250" style="zoom:67%;" />

3. 一个context类, 包含策略类型的字段, 通过向构造函数中传递不同的策略实现类, 保存不同的策略

   <img src="设计模式.assets/1637048070101.png" alt="1637048070101" style="zoom:67%;" />

