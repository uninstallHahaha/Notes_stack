# JVM

***JVM***

```english
	A JVM implementation is a computer program that meets the requirements of the JVM specification. An instance of a JVM is an implementation running in a process that executes a computer program compiled into Java bytecode.
```

***JRE***

```english
	Java Runtime Environment (JRE) is a software package that contains what is required to run a Java program. It includes a Java Virtual Machine implementation together with an implementation of the Java Class Library. 
```

***JDK***

```
	Java Development Kit (JDK) is a superset of a JRE and contains tools for Java programmers, e.g. a javaccompiler. 
```



>   JVM本质就是一个程序
>
>   用来运行java代码 (不是, 只要能够编译成.class文件的语言代码都可以)
>
>   ​	所以说是 , 一次编译, 处处解释, 到哪还得用这个jvm来解释, 然后还得保证解释的时候有第三方包, 要不然结束不通
>
>   JVM本质是解析.class字节码指令的程序





#### 内存结构

这图显然是8以前的版本，方法区存放在永久代，然后紧邻堆

![image-20210714162645771](jvm.assets/image-20210714162645771.png)



##### 程序计数器(PC Register)

> java源码 --编译--> 二进制字节码(jvm指令) --解释器--> 机器码 ----> cpu执行
>
> 在解释器对 jvm 指令进行翻译时, 程序计数器存放下一条 jvm 指令的位置, 解释器执行完一句jvm指令后 , 会去程序计数器中读取下一条指令的地址.
>
> 程序计数器的本质就是一个寄存器
>
> 程序计数器是线程所私有的 : 
>
> ​		Java支持多线程, 即同时在多个线程中执行不同的代码, 每一个线程都私有地拥有一个程序计数器, 当线程用完cpu分配给它的时间片后, 会将当前程序运行到的位置存到自己私有的程序寄存器中, 待到再次得到执行权, 就从自己的程序计数器中获取到程序运行的位置继续运行.



##### 栈

###### 虚拟机栈(JVM Stacks)

虚拟机栈包括 `操作数栈, 局部变量栈, 方法返回值, 动态链接`

> ​		程序开启的线程在执行代码时实际上就是在执行一个个的方法, 而这些方法都需要一段内存来存放参数和变量, 虚拟机栈就是用于存放每个方法的参数和变量的一个栈.
>
> ​		在虚拟机栈中, 每当执行一个方法, 就会生成一个 栈帧 用于存放该方法的参数和变量 , 并将这个 栈帧 放入栈中, 当方法执行完毕后, 这个栈帧就会出栈.
>
> ​		在栈顶部的 即正在执行的方法, 被称为 活动栈帧
>
> ​		在 idea 中, 以debug的方式运行代码, 在执行某个方法的调用之前断点, 逐行执行代码 ,会在debug面板中的 Frames 选项卡中查看到 栈帧的入栈和出栈的过程

​		如下图所示, 每个线程运行时都会创建一个虚拟机栈, 这意味着在栈大小不变的情况下, 每个线程虚拟机栈越大, 那么能同时创建的虚拟机栈就越少

<img src="jvm.assets/1637564795321.png" alt="1637564795321" style="zoom: 40%;" /><img src="jvm.assets/1637564795321.png" alt="1637564795321" style="zoom:40%;" /><img src="jvm.assets/1637564795321.png" alt="1637564795321" style="zoom: 40%;" />

虚拟机栈的特点

> ​		垃圾回收不需要管这个栈, 因为它会随之方法的执行自动地入栈和出栈
>
> ​		可以通过 -Xss< size > 运行参数来设置单个线程栈的大小 , idea 中就是运行设置里的 vm options
>
> ​		栈内存不宜过大, 因为内存总大小就那么大, 栈内存大了, 可以开的线程数就少了, 这样就会影响到运行的效率

栈内存机制涉及的线程安全问题

> ​		方法内的变量是线程安全的, 就是如果有多个线程在同时调用这个方法, 那么它们会在各自的栈中创建各自的一份 栈帧, 这些栈帧都是独立的, 所以不会影响到其他栈中的栈帧.  
>
> ​		但是全局的静态变量是线程不安全的, 因为多个线程每次都要从全局来读取它, 这样就会造成数据的读写混乱.
>
> ​		如果方法内的变量是引用类型且仅仅在方法内自己玩 , 也就是随着方法的调用结束而被回收, 那么它是线程安全的, 但是如果它的不是仅仅在方法内自己玩, 它就不是线程安全的

栈内存溢出:

> 1. 栈帧过多会导致栈内存溢出 , 例如没有结束条件的递归
> 2. 栈帧过大会导致栈内存溢出



###### 本地方法栈

> ​		有些与操作系统交互的方法仅靠java无法实现,所以需要调用一些 c 或者 c++ 实现的方法, 这些方法被称为本地方法, 使用 native 修饰 
>
> ​		本地方法栈就用来提供本地方法运行时所需要的内存空间



##### 堆

###### 堆内存结构

​		分代式实现：分为 `Eden`，`survivor from`，`survivor to`，`old`

###### 为什么分代管理？

​		<span style='color:cyan;'>本质是减少对长时间存活对象的回收次数，因为这样的操作相当于纯浪费时间的无效操作</span>

​		gc 时候需要检查相关引用，如果不分代的话，需要对整个内存进行遍历，这将会造成很长时间的 STW，严重损耗性能，分代的话，minor gc 只遍历新生代进行垃圾回收，这样能够大幅度减少 STW 时间

​		同时，对象本身就存在生命周期长短的差异，如果一个对象获得可能比较长，那么就少对它尝试回收，这样就可以提高 gc 的效率

​		但是如何知道谁比较可能活的长呢，当然是已经活的很长的对象比较有可能活的更长，所以才会有进入老年代的阈值以及不频繁 gc 的设定

​		假设可用内存无限大，那么就不需要 gc，此时肯定就不需要分代了，但是事实是内存总是宝贵的，又不能任由 java 程序不断扩张，所以就要选择速度快，而且能够干活快结果好的gc策略，也就是频繁的 minor gc 和 偶尔的full gc 策略



###### 对象实例

> 通过new 创建的对象都会放到堆中
>
> 堆中的数据都是线程共享的
>
> 堆中的数据会被gc回收
>
> 可通过运行参数 -Xmx< size > 来设置最大堆内存
>
> -Xms 设置初始堆内存

堆内存溢出

> 在对象不被回收的情况下, 无限创建对象 会导致堆内存溢出

###### 运行时常量池

> 运行时常量池(stringtable) 就是用来存放字符串常量的
>
> 每当出现一个新的字符串常量时, 就生成一个新的串存到串池里, 下次在使用字符串常量时, 先在串池中查找, 有则直接使用, 没有就创建新的放入stringtable

> 在版本1.6中, 串池( stringtable )位于方法区
>
> 在版本1.6以后, stringtable 位于堆内存中 , 因为堆的垃圾回收更加频繁, 能够减少字符串常量所占的内存

> 在java代码中通过调用 String类型变量的 intern() 方法手动将该String对应的字符串存到 StringTable中, 然后返回该字符串在 stringtable 中的地址
>
> 在 1.6 中, 调用 intern() 方法时, 会复制一份字符串常量存到stringtable中
>
> 在 1.8 中, 调用 intern() 方法时, 直接将该String对象的地址存到stringtable中 

###### stringtable调优

> stringtable的数据结构是hash表, 即总共有 n 个 bucket, 每一个 bucket中以链表的方式 存放一定hash范围内的数据
>
> 这个总的 bucket 的个数越多, 也就是hash分段越细, 那么在向 stringtable 中添加新的 字符串常量时就越容易找得到它应当被存到哪个 bucket 中, 从而存储效率也就越高.
>
> 所以如果有很多个 字符串常量要存储在 stringtable 中时, 适当的增大 bucket 个数, 能够提高数据存储的效率
>
> 通过运行参数 -XX:StringTableSize=200000 来设置 bucket 的个数

###### stringtable应用

> ⭐ 假设有大量的字符串数据, 其中有不少是重复的, 现在要在程序中将它们存储到一个 List 中
>
> 1️⃣ 如果使用 new String 的方式来创建它们, 那么这些字符串会一个不差地被创建为新的 String 对象被存到堆中
>
> 2️⃣ 如果将这些字符串 通过调用 intern() 放入 stringtable 中, 然后将该方法返回的值即它在 stringtable 中地址存到 List 中, 因为 stringtable 不会存重复数据的特性, 所以这就相当于使用了更少的空间存储了更多的数据, 极大地降低了内存的使用 

###### TLAB

>   提高多线程情况下申请内存的效率

​		为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer) 的技术

​		多线程的情况下，各个线程都是在 Eden 中申请内存，如果不加以同步，可能造成数据错乱的问题，但是使用同步又会使得内存分配效率低下

​		所以 HotSpot 虚拟机就提供了一种方法，即事先给各个线程在 Eden 中分配专属的区域，那么在申请内存时，无需考虑同步问题，直接从自己所属的区域中申请即可

​		专属区域仅仅用来区分写操作，对于读操作它们是对所有线程可见的

​		当然，如果线程专属区域不足以放下新对象，那么还是需要结合同步在Eden的其余区域进行创建

![image-20210818141240766](jvm.assets/image-20210818141240766.png)









##### 方法区

>   注意，方法区只是 JVM 的一个规范区域，具体到每个厂家每个版本的实现中，方法区由不同的内存位置来实现

<span style='color:cyan;'>存放类的 字段, 方法（类的元数据） 和 字符串常量池</span>

类的元数据包括 `类的版本, 字段, 方法, 接口, 父类信息`

​		注:   1.6及以前, 字符串常量池在方法区

​				1.7字符串常量池在堆

​				1.8及以后字符串常量池在元空间

<span style='color:cyan;'>方法区在 1.8以前放到 永久代, 1.8以后放到 元空间</span>

*   java1.8 以及以后 , 通过运行参数 -XX:MaxMetaspaceSize=8m 来设置大小

*   java1.8 以前 , 通过运行参数 -XX:MaxPermSize=8m 来设置大小



###### 静态常量池

> 用于存放java程序编译成为 class 对象后每一步java指令所使用的 值



###### 永久代

​		JDK1.8以前的HotSpot JVM有**方法区**，也叫**永久代(permanent generation)**

​		永久代的**GC**是和老年代(old generation)捆绑在一起的，无论谁满了，都会触发永久代和老年代的垃圾收集





**为什么要用Metaspace替代方法区？**

​		 随着动态类加载的情况越来越多，这块内存变得不太可控，如果设置小了，系统运行过程中就容易出现内存溢出, 也也就是OOM，设置大了又浪费内存

​		而元空间在实现上直接使用主机内存, 不属于 JVM 内存, 那么就无需考虑给方法区分配多少内存





###### 元空间

​		在 8 及以后, 因为方法区使用元空间的位置，而<span style='color:cyan;'> 元空间直接使用物理内存空间 </span>, 就是主机的内存

​		所以 8 以后，方法区的大小不再受限于堆空间的大小，而是取决于本地内存（native memory）的大小

​		元空间存放类的元定义数据 Klass（matadata），在堆中创建对象时，首先来元空间寻找对应的Klass定义，然后在堆中为其分配地址创建对象

​		类加载器就是将字节码文件中的类定义加载为 Klass 定义，保存到元空间中，所以元空间中每个 Klass 定义都与类加载器一一对应

​		当某个类加载器关联的所有 Klass 在堆中不存在实例时，该类加载器会被垃圾回收，对应的，元空间中相关的 Klass 定义也会被垃圾回收，所以，<span style='color:cyan;'>方法区类的定义并不是永久存在的</span>

![image-20210830155819690](jvm.assets/image-20210830155819690.png)

Metaspace由两大部分组成：<span style='color:cyan;'>Klass Metaspace</span> 和 <span style='color:cyan;'>NoKlass Metaspace</span>

-   **Klass Metaspace**

1.  Klass Metaspace就是用来存**klass**的，就是class文件在jvm里的运行时数据结构（不过我们看到的类似A.class其实是存在heap里的，是java.lang.Class的对象实例）。
2.  这部分默认放在**Compressed Class Pointer Space**中，是一块连续的内存区域，
     紧接着Heap，和之前的perm一样。通过-XX:CompressedClassSpaceSize来控制这块内存的大小，默认是1G。
3.  Compressed Class Pointer Space**不是必须有的**，如果设置了**-XX:-UseCompressedClassPointers**，或者**-Xmx设置大于32G**，就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里。

-   **NoKlass Metaspace**

1.  NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，可以由多块不连续的内存组成。
2.  这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。
3.  NoKlass Metaspace在本地内存中分配。



<span style='color:red;'>Metaspace OOM问题</span>

​		Metaspace 的总使用空间达到了 MaxMetaspaceSize 设置的阈值，或者 Compressed Class Space  被使用光了，如果这次 GC 真的通过卸载类加载器腾出了很多的空间，这很好，否则的话，我们会进入一个糟糕的 GC 周期，即使我们有足够的堆内存。

​		所以不要把 MaxMetaspaceSize 设置得太小，会造成莫名其妙的频繁GC











##### 直接内存

> 这一部分的内存来自物理内存, 不属于分配给 Java 程序的内存
>
> 一般用于 nio 读写文件操作时的缓冲区域
>
> 调用 ByteBuffer.allocateDirect(_1GB); 可从操作系统获得对应大小的物理内存
>
> ( 不推荐, 这个方法一般是jdk内部自己调用 )或者调用 Unsafe 类型实例的 allocateMemory(_1Gb) 获取直接内存
>
> 回收时调用 Unsafe 实例的 freeMemory() 方法
>
> ByteBuffer.allocateDirect() 实际上也是调用了 Unsafe 的 allocateMemory() 方法, 然后由 Cleaner 虚引用来监测 ByteBuffer 的状态, 当 ByteBuffer 被回收时, cleaner 调用 freeMemory() 方法实现释放直接内存

> 在运行参数中设置 -XX:+DisableExplicitGC 禁用在代码中显式地调用垃圾回收,即 System.GC() , 这样会造成直接内存不会被释放直到对应的变量被销毁, 此时可以通过调用 unsafe 对象的 freeMemory() 实现对直接内存的回收





##### 参数设置

*   Xss 设置单个线程栈的大小，不能太大，太大的话能够同时开的线程数就变少，最小值默认为228k
*   Xms  初始堆内存，默认物理内存 1/64
*   Xmx  最大堆内存，默认物理内存 1/4
*   Xmn  新生代大小，覆盖 XX:NewRatio 设置
*   XX:MetaSpaceSize  元空间大小（用来放方法和字符串常量池，直接使用物理内存）
*   XX:SurvivorRatio  一个幸存区/Eden区 的 比例，注意有两个幸存区，它们的相同，这里设置的是一个的比例
*   XX:NewRatio  新生代/老年代 的 比例
*   XX:MaxTenuringThreshold  进入老年代的阈值











#### 垃圾回收

##### 如何判断对象是否可以回收

1. 引用计数法

   ​	就是当对象被引用时计数加一, 失去被引用计数减一, 当引用数为零时, 意味着它可以被回收

   ​	但是如果存在两个对象的相互引用, 那么这两个对象就永远不会被垃圾回收

   ​	jvm中不采用此种回收机制

2. 可达性分析算法

   ​		先确定根对象,即GC Root对象, 然后查看目标对象是否被根对象所引用, 如果没有被根引用则可以作为垃圾进行回收

   ​		也就是说，从这些根对象出发，看看它们都引用到了哪些对象，未被这些根对象引用的对象将被回收
   
   ![image-20210929134008231](jvm.assets/image-20210929134008231.png)
   
   ​		<span style='color:cyan;'>finalize 方法，给对象一次起死回生的机会</span>
   
   ​		a, b 对象可回收，就一定会被回收吗?并不是，对象的 finalize  方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行  finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC  会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！
   
   ​		**注意：** finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!





##### 四种引用类型

1. 强引用

   ​	一般在代码中创建的对象都是强引用类型

   ​	通过 new 新建的对象然后通过 = 赋值给一个变量, 这种就被成为强引用, 只要某一对象存在被 gc root 对象强引用, 就不会被垃圾回收

   ​	专业来说, 只要在栈里面存在对堆对象的引用, 就是强引用

2. 软引用

   ​	在垃圾回收之后仍然内存不足时, 会发起对软引用对象的回收, 在代码中通过 new SoftReference() 来创建软引用对象,

   ​	创建软引用对象时可通过传参指定绑定一个 引用队列, 当软引用对象引用的对象被回收时, 该软引用对象会被加入到 引用队列中, 此时可通过引用队列中的元素来回收指定的软引用对象

3. 弱引用

   ​	在垃圾回收时不管内存紧不紧张都会被回收的引用类型, 在代码中通过 new WeakReference() 或者 new WeakHashMap() 来创建

   ​	同 软引用 可配合引用队列来实现 对引用对象本身的记录和清理

   ​	WeakHashMap 和 HashMap 的区别就是 弱引用 和 强引用

4. 虚引用

    ​	软引用对象和弱引用对象在失去引用而将要被回收时, 不是直接回收, 而是加入引用队列, 待到下次gc, 直接从引用队列里出队然后才回收

    ​	如果想要观测其他对象的回收时机, 或者在它们回收之前做一些操作, 那么使用虚引用, 虚引用被创建时就直接加入引用队列, 在执行gc前如果是队头那么会提前出队, 此时会收到通知, 就可以在此处添加操作

5. 终结器引用



##### 垃圾回收策略

> 三种方法在 jvm 中分不同的情况都有使用

###### 标记清除

先看看对象是否与 GC Root 对象有引用关系 , 如果没有, 那么就把这个对象占用的起始和终止位置记录到空闲内存列表中, 供新对象创建时查询并使用

优点: 快

缺点: 会产生内存碎片

###### 标记整理

先看看对象是否与 GC Root 对象有引用关系 , 如果没有, 那么就把这个对象占用的位置标记为空闲, 然后将内存中其他对象使用这些空闲位置进行紧凑整理, 结果就是没有了内存碎片

优点: 没有内存碎片

缺点: 慢

###### 复制

将整个内存分为两个大小相同的区域 , 分别为 from 和 to, 其中只用 from 来存对象, to 保持为空, 当垃圾回收时, 先根据 GC Root 的引用关系对对象进行是否被回收的标记, 然后将存活的对象都复制到 to 区中, 随后清空 from 区, 最后交换 from 和 to 的名字

优点: 没有内存碎片, 相对标记整理快

缺点: 浪费内存



###### 分代垃圾回收

​		分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起

<img src="jvm.assets/image-20210818123438883.png" alt="image-20210818123438883" style="zoom:67%;" />

***分代垃圾回收的流程***

![图片](jvm.assets/minorGC)

1.  新创建的对象保存到 伊甸园区 中

2.  伊甸园满了时, 触发 minor gc 垃圾回收

    存活的对象、幸存区from中的对象 复制到 幸存区 to 中, 并且标记它的寿命加一 

    如果寿命已经大于老年代阈值，移动到老年代

    最后清空伊甸园

    交换 幸存区from 和 幸存区to

> ​		当老年代满了时 , 触发对整个内存的 full gc 垃圾回收（stw） , 本次回收完后, 如果发现内存还是不够, 那么会抛异常 outofmemory

> ​		gc时, 为防数据混乱, 会暂停其他线程只运行垃圾回收这个线程

> ​		对于大小超过了新生代总容量的对象, 如果老年代能存下, 直接存到老年代中

> ​		子线程内发生的内存溢出不会影响主线程的正常运行

**空间分配担保**

​		在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间

​		如果大于，那么Minor GC  可以确保是安全的

​		如果不大于，那么虚拟机会查看 HandlePromotionFailure  设置值是否允许担保失败

​		如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小

​		如果大于则进行 Minor  GC，否则可能进行一次 Full GC。

**Stop The World**

​		如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。

​		什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。

<span style='color:lightblue;'>*画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。*</span>

​		一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理**整个堆**中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！

​		所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的  STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）

​		由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe  Point，这个时间点的选定既不能太少以让 GC  时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。

​		一般当线程在这个时间点上状态是可以确定的，如确定 GC Root  的信息等，可以使 JVM 开始安全地 GC

![1595149937053](1595149937053.png)



##### 垃圾回收器的种类

###### 串行垃圾回收器

> 通过设置虚拟机参数启用 -XX:+UseSerialGC=Serial+SerialOld

* 单线程执行垃圾回收任务
* 适合堆内存较小时的情况, 就一个线程在这干活, 堆内存太大了得回收很长时间, 适合单核的cpu, 因为单核cpu只能开一个线程

如果在多核机器上使用了串行垃圾回收器, 那么流程如下:

![1595151873899](1595151873899.png)



###### 并行垃圾回收器

> 通过设置虚拟机参数启用 -XX:+UseParallelGC 开启该回收器 , 在 jdk1.8中默认使用这个
>
> 通过设置参数设置使用的线程数: -XX:ParallelGCThreads=n

* 多线程执行垃圾回收
* 适合多核cpu , 因为只有多核才能真正开多个线程, 从而提高效率
* 策略是让单位时间内, 执行垃圾回收时其他线程停止的时间尽量短, 从全局考虑问题

垃圾回收时的流程:

![1595152054920](1595152054920.png)



###### CMS回收器(并发标记清理)

> 通过设置参数开启该回收器 -XX:+UseConcMarkSweepGC
>
> 响应时间优先

* 多线程执行垃圾回收
* 适合多核cpu
* 策略是让单次垃圾回收时, 其他线程停止的时间尽量短, 仅着眼于眼前考虑问题

<span style='color:cyan;'>CMS回收器与并行垃圾回收器的区别</span>在于, 并行垃圾回收器进入gc时, 就从标记到清理一套执行完毕才结束, 而CMS把标记和清理分离, 且部分标记操作是并发执行的, 清理工作也是并发执行的, 这样就提高了程序的响应时间, 不会因为需要等待完整的gc时间而停顿很久

<span style='color:pink;'>垃圾回收的流程</span>

1.  <span style='color:cyan;'>初始标记</span> : 单开一个垃圾回收线程标记工作线程中直接引用的对象, 此时工作线程阻塞，初始标记只标记直接被 Root 对象引用的对象，为的是尽量减少 STW 的时间，提升用户体验
2.  <span style='color:cyan;'>并发标记</span> : 垃圾回收线程与工作线程并发执行, 垃圾回收线程根据上一步标记出引用到的对象, 对所有对象进行遍历, 以确定哪些对象需要被清理
3.  <span style='color:cyan;'>重新标记</span> : 由于上一步中并发执行的工作线程可能导致对象引用的变化, 为了防止清理掉还在被引用的对象, 这一步中多个垃圾回收线程并发遍历变更引用对象所关联的对象, 以更新哪些对象应当被清理
4.  <span style='color:cyan;'>并发清理</span> : 此时, 已经正确标记出当前状态下哪些对象需要被清理, 垃圾清理线程与工作线程并发执行, 垃圾清理线程进行对象回收

![1595152580893](1595152580893.png)



###### G1 垃圾回收器

> 一种同时注重吞吐量和低延迟的回收器
>
> 在 jdk9 及之后为默认的垃圾回收器
>
> 通过设置参数 -XX:+UseG1GC 使用该垃圾回收器

​		将堆内存分为离散的region(格子), 每个格子都有不同的角色(eden, servivor, old), 清理过程依然是标记, 复制, 清理

​		在标记的过程中，会对各个 region 的清理收益和清理时间进行估计，然后给出清理的优先次序，根据用户限定的 stw 时间按照优先度从高到低选择合适的 region 进行清理，因此 G1 的 stw时间是控的





##### 对象进入老年代的方式

*   正常的年龄增长至阈值，进入老年代

*   如果 survivor 存不下活跃的对象时，直接进入老年代

*   动态年龄

    servivor 已满，且至少有50%对象年龄大于平均年龄，那么这些大于平均年龄的对象直接进入老年代

*   大对象直接进入老年代

    大对象在Survivor里存不下，也直接进入old区
    
    **tips:只针对Serial和Parnew收集器生效，PS收集器无效**





##### gc时间过长卡顿

1.  优化代码, 少new一些对象
2.  新生代内存分的太少, 总是发生 minor gc, 然后其中的对象寿命也增加的很快, 导致它们很快就进入老年代, 然后等到 full gc 的时候就得花更多时间
3.  GC算法不行, 换一个
4.  jvm进程内存被swap到交换内存里, 那么此时gc的就是硬盘, 会很慢
5.  GC线程太少
6.  调用了太多的 System.gc(), 这个是 full gc
7.  堆内存太大, 所以gc很耗时





#### 类加载

> 编译时将 java 文本文件编译成 class 文件
>
> 运行时首先需要将 class 文件中的类加载到内存方法区, 以便之后的使用

###### class文件的结构

> 详情可查看 oracle 官方 jvm规范

> class 文件的结构应当遵循 jvm 规范, class文件使用十六进制表示
>
> class 文件中各个位置的数据代表含义如下
>
> 其中 u4, u2 代表4个字节和2个字节(一个字节是二进制八位, 这里是十六进制, 所以一个字节就是一对挨着的数字)

![1595318622045](1595318622045.png)

> class 文件的前四个字节 : 魔数 , 用来表示它是否是 class 类型的文件 , 不同的 魔数 代表不同类型的文件, class 文件的 魔数 是 cafe babe

![1595318771907](1595318771907.png)

> 接下来四个字节是 版本号, 其中前两个字节是 minor 版本号, 后两个字节是 major 版本号 
>
> 比如下面这个 major 版本号为 34, 那么就代表编译器版本时 JDK8

![1636344856773](jvm.assets/1636344856773.png)

![1595318887766](1595318887766.png)

> 常量个数

![1595318981831](1595318981831.png)

> 接下来就是各个常量的具体数据

> 其中每一个常量的前两位代表该常量的类型, 对应关系如下表
>
> 常量的存储格式 : 常量类型(一个字节) + 常量长度(两个字节) + 常量数据(常量长度值的字节数)

![1595319140706](1595319140706.png)

> 例如

![1595319210925](1595319210925.png)

> 访问标识
>
> 访问标识对应关系如下表

![1595319976990](1595319976990.png)

> field成员变量
>
> 成员变量类型对应如下表

![1595320087839](1595320087839.png)

###### 反编译 class 文件

>   使用javap 反编译 class 文件

```
// -v 代表同时编译常量池信息
# javap -v xxx.class
// 接下来会显示该 class 文件的结构信息
```

###### 指令集方法执行流程

> 字节码文件中的 字节码指令 对应一套 指令集 , 这套指令集只是为了方便人们理解的一种表示方式

1. 将常量池的内容加载到 运行时常量池中

2. 将用到的类加载到 堆内存 中

3. 将方法代码转换成为 指令集, 加载到 方法区

4. 开始执行方法时, 执行引擎创建一个 帧栈 来执行该方法, 每一层方法的调用都会为其创建一个帧栈 

   该帧栈包括 :

   参数槽 : 用来存放参数和变量 , 其个数事先根据方法计算得出

   操作栈 : 用来执行数据的操作 , 先将数据加载到操作栈中, 然后在其中进行运算

5. 参数和变量保存到 参数槽 中, 进行运算时就把数据加载到 操作栈中 进行操作

![1595323691980](1595323691980.png)

> 关于 ++ 操作:
>
> ++ 操作是可以直接在参数槽上执行的指令
>
> a++ 和 ++a 的本质区别在于, 是先将数据加载到操作栈中然后再在参数槽上自增 , 还是先在参数槽上自增然后再加载到操作栈中

> 条件判断指令 和 循环控制指令 :
>
> 本质上是先使用判断指令得到结果, 然后使用 goto 指令跳转到代码的指定行
>
> while 和 for 的字节码指令实际上一模一样

###### cinit初始化

> 编译器会将代码中的静态代码部分整合为一个方法, 这个方法被称为 cinit 方法, 在执行常规的方法代码前执行该方法

###### init初始化

> 在类的初始化时, 会首先将类内的 {} 代码块和对成员变量的赋值整合成一个方法, 这个方法被称为 init 方法, init 方法会在 类的构造方法 之前调用

###### try/catch/finally 的实现

> 带有 try/catch 的代码会在编译后生成一个 exception table ,用于记录那些行的执行结果需要被监控是否出现了指定的异常, 有则 goto 跳转到 catch代码块编译后的指令行

> finally 实际上是在编译过程中, 将 finally 代码块中的内容复制了三份分别放到了 try 代码块后面, catch 代码块后面 , catch 为捕获类型的异常代码后面

> 如果在 finally 代码块中包含了 return 语句, 那么编译为字节码指令后将不会生成 athrow 指令(抛异常), 同时使用 finally中的return作为返回标准, 即使 try 中也包含 return语句, 所以***不要***在finally 代码中写 return 语句, 会导致异常被吞掉

#### 类加载器

> 类加载器机制的优势在于可以自定义类的加载逻辑
>
> 类加载器（ClassLoader）是Java语言的一项创新，也是Java流行的一个重要原因。在类加载的第一阶段“加载”过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是类加载器。这一动作是放在Java虚拟机外部去实现的，<span style='color:cyan;'>以便让应用程序自己决定如何获取所需的类</span>

###### 带来唯一性

​		通俗的说，JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。

​		这里的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。

###### 类加载器做什么?

​	JVM运行class文件, 需要先将其中的类加载到方法区, 之后才能在运行代码时找到这些类然后创建实例, 类加载器就是将class文件中的类读取到方法区.

###### JVM自带的类加载器?

​	JVM里面自带了 `Bootstrap ClassLoader` , `Extention ClassLoader`, `Application ClassLoader`, 用来加载java核心类, java扩展类, 自定义引用的第三方类, 它们自右向左依次继承, JVM在运行之初, 就把这些类加载到了方法区

从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader

###### 双亲委派加载机制

​	JVM 的类加载机制: 首先获取到指定的类加载器, 然后交给其父类加载器处理, 一直向上, 直至到达最基础的 Bootstrap ClassLoader , 如果某个父加载器无法加载, 就使用当前类加载器加载, 所以类加载器实际上就是一段代码, 大致逻辑就是通过io流读取class文件, 然后将读取到的字节流转换为类的定义(调用 defineClass), 然后将类定义放到方法区.

###### 为什么双亲委派

​		使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。

​		在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

这是一个典型的使用双亲委派机制来实现的类加载器

![1637046825883](jvm.assets/1637046825883.png)

<span style='color:pink;'> 注意，双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现 </span>

###### 自定义类加载器

![1637046457891](jvm.assets/1637046457891.png)

<img src="jvm.assets/1637046467849.png" alt="1637046467849" style="zoom:67%;" />

###### 自定义类加载器的作用?

1.  同时加载同一个类的多个版本

​	但是, 如果要同时加载多个相同的类, 那就无法实现, 因为它们的全限定类名相同, 而且类加载器相同, 所以在加载的时候一看两个一样, 那么就只会加载一个 

​	如果想要同时加载多个全限定类名相同的类, 可以使用自定义的类加载器来加载

​		因为 JVM 判断两个要加载的类是否完全相同的依据是 `全限定类名+使用什么类加载器加载` , 在方法区的类 Klass 结构都是与其类加载器对应的，所以同一个类加载器对应的 Klass 不能重复，因此如果想要同时加载多个相同 Klass 类名的类，就要使用不同的类加载器加载, 就可以实现同时加载多个完全相同的类

​	这在大型项目中很有用处, 因为多个第三方可能同时依赖了同一个包的多个不同版本, 如果直接使用 JVM的默认类加载, 那么这些类不能同时加载, 就可能出现 `NoSuchMethod` 错误

2.  热加载

​    每当业务代码中的类更新时, 就需要对内存中业务代码部分进行更新吧? 此时就需要调用它的类加载器更新内存上的对应部分

​	如果使用默认的类加载器, 那么与它关联的所有 Klass 都需要重新加载，也就是会将整个项目都重新加载一次, 而业务代码往往在项目中占比是很小的, 因为很小的改动就需要重新加载整个项目到内存上, 这无疑是在浪费时间 

​	高效的做法是使用自定义的类加载器, 在其中只加载业务代码部分, 然后在项目启动时开一个线程, 监听业务代码的改动, 每当业务代码有改变时, 就执行自定义的类加载器只更新内存中业务代码部分, 这样就省去了大量时间, 也就实现了热加载.

3.  给class文件加密

​    通常情况下, 因为从 .java 文件到 .class 文件都遵守严格的 jvm 规则, 那么也可以根据这个规则, 从 .class 反编译得到 .java 文件 

​	如果不想让别人得到源码, 就需要对 .class 进行加密, 但是 jvm显然是不能识别加密后的 .class 文件的, 因此可以先把 .class 根据自己的规则加密, 然后使用自定义的类加载器, 在加载 .class的时候先对其进行解密, 然后就可以将解密后的类加载到内存中.






几种类型的类加载器

![1595643255768](1595643255768.png)



#### 线程安全

线程安全问题可以通过 synchronized 和 CAS技术 来实现

###### synchronized 

> 实际上就是使用一个对象将其标记为锁对象, 然后执行目标加锁代码, 这要求多个线程同时使用同一个对象作为锁对象
>
> 该方法的实现的思想为 悲观锁, 即我来了就把对象锁住, 其他人不能访问,我走之后别人才能访问

###### Lock

>   J.U.C 包中提供的 Lock 系列类利用悲观锁的思想能够帮助提供线程安全

###### CAS

> 实际上就是多次尝试, 每次执行完操作后都对原值进行检查, 如果检查后发现原值和实际值不相同, 那就说明在我操作的过程中别的线程对该数据进行了操作, 那么此时就重新再操作一次, 直至检查后发现原值和实际值相同, 才把操作结果返回. 
>
> 该方法的思想为 乐观锁, 即我不断尝试进行操作, 如果别人把原来的值改了, 那我就重新再做一次. 
>
> CAS是无锁的线程安全的操作, 能够提高程序运行的效率
>
> JUC 的 AtomicXXX 就是使用乐观锁的思想







#### JMM模型

JMM模型规范要求保证三点：原子性，可见性，有序性

`原子性`：操作要求原子执行，是不可再分的操作

`可见性`：一个线程对数据的操作要求其他的线程能够立即得到，而不是得到缓存中得旧值

`有序性`：是指操作是否能够按照既定的代码顺序执行，因为存在cpu指令运行顺序优化，可能会导致指令重排







#### Server模式 和 Client模式

 JVM有两种运行模式Server与Client。

两种模式的区别在于，Client模式启动速度较快，Server模式启动较慢；

但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。

这是因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化；

而Client模式启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。

开发环境建议 Client 模式即可, 生产环境换成 Server 模式

通过 `java --version` 查看当前 JVM 使用的模式

 ![1636599950421](jvm.assets/1636599950421.png)

