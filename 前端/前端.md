###### [语义化标签](https://segmentfault.com/a/1190000013901244)

###### [input标签类型](https://blog.csdn.net/qq_36171618/article/details/80802588)



###### [伪类和伪元素](https://www.jianshu.com/p/c7dcb3008e5c)



###### [元素水平垂直居中](https://www.cnblogs.com/linsinan/p/6132241.html)



###### [position属性值](https://blog.csdn.net/weixin_44589540/article/details/115400664)



###### [css选择器](https://blog.csdn.net/lucky541788/article/details/81625347)



###### [回流和重绘](https://www.cnblogs.com/youguo2/p/10933043.html)



###### [Js数据类型](https://www.runoob.com/js/js-datatypes.html)

**值类型(基本类型)**

​		字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol

**引用数据类型**

​		对象(Object)、数组(Array)、函数(Function)



###### [null和undifined区别](https://www.cnblogs.com/shengmo/p/8671803.html)



###### [Symbol](https://www.runoob.com/w3cnote/es6-symbol.html)



###### [Js原型](https://www.jianshu.com/p/72156bc03ac1)



###### http协议

无状态，客户端/服务器模式，快速响应的设计，同时存在安全问题

<span style='color:cyan;'>请求格式</span>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>方法</div>	<div style='display:inline-block;padding:5px;background:blue;color:black;'>URL</div>	<div style='display:inline-block;padding:5px;background:pink;color:black;'>版本</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>...</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>请求体内容</div>



<span style='color:cyan;'>响应格式</span>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>版本</div>	<div style='display:inline-block;padding:5px;background:blue;color:black;'>状态码</div>	<div style='display:inline-block;padding:5px;background:pink;color:black;'>状态码描述</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>...</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>响应体内容</div>





###### CRLF注入

​		因为在请求数据中，它是根据CRLF，也就是 \r\n 来表示某一行的结束，那么用户就可以恶意的在 URL 后面手动加上 CRLF ，然后再加一些恶意的 key：value，这样服务端就会解析到恶意的 key：value，从而造成安全问题

​		解决方法是在服务端对请求数据进行清理，去掉不符合规范的 CRLF 字符





###### http调优

http请求基于tcp连接来通信，首先是得两台要通信的计算机建立tcp连接，

然后在该连接上发送和接收数据，

<span style='color:yellow;'>*长连接*</span>

​		http请求具有短暂和突发的特点，也就是定不准什么时候就突然请求一下资源

那么如果每次要发送http请求时，都重新建立tcp连接，那么就得每次都经历三次握手和四次挥手的申请内存和释放内存的活动，这样时间将都被浪费在这里，

所以，应当使用长连接的方式，复用同一个tcp连接，多次进行http请求，这样就初步提高了http的性能，该方案就是 http1.1 做出的改进

<span style='color:yellow;'>*tcp慢启动*</span>

​		但是还存在一个问题，就是tcp连接存在慢启动机制，还记得在linux中的tcp设置吗？其中有一个设置是发送和接收窗口的大小，这里设置的是一个范围，也就是刚建立连接时，设置窗口大小为初始值，然后根据网络情况不断增大至最佳性能，这个设计的目的是避免多个tcp连接一上来就发送大的数据包从而造成路由器缓存被占满从停止响应的问题，这就是慢启动机制

显然，http请求属于时不时来一下子的数据交互，因为慢启动机制的存在，http请求将总会吃到最开始的慢速度，所以最直接的方式就是关闭linux中tcp设置的慢启动功能

就像这样关闭了，就可以很直接地提升http请求的用户体验

![image-20210915212640832](前端.assets/image-20210915212640832.png)

<span style='color:yellow;'>*拥塞窗口的初始值*</span>

​		看完了tcp慢启动问题，显然，我们也可以通过把拥塞窗口的初始值大小设置得大一些来直接提高http的用户体验





###### http版本差别

1.0

短连接，一个http请求建立一个tcp链接

只定义了 get， post， head 三种

1.1

支持六种 get，post，head，delete，put，options

长连接，一个tcp连接一直用来进行http请求和响应，直至http请求中设置 connection: close，但是这些http请求是串行地使用这个tcp连接

2.0

多路复用tcp连接，也就是在一个tcp连接中可以同时发送多个http请求和响应，它们根据不同的id号区分

客户端和服务端同时保存head cache，那么在发送http请求时，不再需要发送重复的请求头参数，只需要增量发送请求头参数即可

使用二进制的方式传递数据，也就是数据都使用01的方式传递，这样就避免了字符传递时大部分的错误，之前都是字符文本传输

支持服务端主动向客户端发送数据了

数据压缩传输，这样更节省带宽





###### [XSS攻击](https://zhuanlan.zhihu.com/p/26177815)

先上一段标准解释（摘自百度百科）。

>   “XSS是跨站脚本攻击(Cross Site  Scripting)，为不和层叠样式表(Cascading Style Sheets,  CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。”

​		相信以上的解释也不难理解，但为了再具体些，这里举一个简单的例子，就是留言板。我们知道留言板通常的任务就是把用户留言的内容展示出来。正常情况下，用户的留言都是正常的语言文字，留言板显示的内容也就没毛病。然而这个时候如果有人不按套路出牌，在留言内容中丢进去一行

```js
<script>alert(“hey!you are attacked”)</script>
```

那么留言板界面的网页代码就会变成形如以下：

```html
<html>
    <head>
       <title>留言板</title>
    </head>
<body>
<div id=”board” 
        <script>alert(“hey!you are attacked”)</script>
</div>     
    </body>
</html>
```

​		那么这个时候问题就来了，当浏览器解析到用户输入的代码那一行时会发生什么呢？答案很显然，浏览器并不知道这些代码改变了原本程序的意图，会照做弹出一个信息框。

​		其实归根结底，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。

**XSS攻击能做什么**

*   **窃取网页浏览中的cookie值**

    ```js
    // 使用该api获取cookie
    document.cookie
    ```

*   **劫持流量实现恶意跳转**

    ```js
    <script>window.location.href="http://www.baidu.com";</script>
    ```

**如何绕过XSS检查**

*   **大小写绕过**

    >   http://192.168.1.102/xss/example2.php?name=<sCript>alert("hey!")</scRipt>

*   **利用过滤后返回语句再次构成攻击语句来绕过**

    删一个 script 标签，还剩一个 script 标签

    >   http://192.168.1.102/xss/example3.php?name=<sCri<script>pt>alert("hey!")</scRi</script>pt>

*   **利用其他标签的事件来插入代码**

    >   http://192.168.1.102/xss/example4.php?name=\<img
    >   src='w.123' onerror='alert("hey!")'>

*   **用eval执行编码后的代码**

    例如alert(1)编码过后就是

    ```text
    \u0061\u006c\u0065\u0072\u0074(1)
    ```

    所以构建出来的攻击语句如下：

    >   [http://192.168.1.102/xss/example5.php?name=eval(\u0061\u006c\u0065\u0072\u0074(1))](https://link.zhihu.com/?target=http%3A//192.168.1.102/xss/example5.php%3Fname%3D%3Cscript%3Eeval(/u0061/u006c/u0065/u0072/u0074(1))%3C/script%3E)

**XSS攻击大致上分为两类：**

>   一类是反射型XSS，又称非持久型XSS，
>   一类是储存型XSS，也就是持久型XSS。

**什么是反射型XSS**

​		其实，我们上面讲XSS的利用手段时所举的例子都是非持久型XSS。

​		也就是攻击相对于访问者而言是一次性的，具体表现在我们把我们的恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。

​		也就是说想要触发漏洞，需要访问特定的链接才能够实现。

**什么是储存型XSS**

​		它与反射型XSS最大的不同就是服务器再接收到我们的恶意脚本时会将其做一些处理。

​		例如储存到数据库中，然后当我们再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。

​		还记得在文章开头提到的留言板的例子吗？那通常就是储存型XSS。当有人在留言内容中插入恶意脚本时，由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪。

​		这个过程一般而言只要用户访问这个界面就行了，不像反射型XSS，需要访问特定的URL。

**防范手段**

-   首先是过滤。对诸如<script>、<img>、<a>等标签进行过滤。
-   其次是编码。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。
-   最后是限制。通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。





###### Http-Only

​		如果支持HttpOnly的浏览器检测到包含HttpOnly标志的cookie，并且客户端脚本代码尝试读取该cookie，则浏览器将返回一个空字符串作为结果。这会通过阻止恶意代码（通常是XSS）将数据发送到攻击者的网站来使攻击失败。

​		也就是说，Http-Only 用于防范 XSS 攻击中的窃取 cookies 操作





###### Script中的defer和async

普通script

也就是遇到什么解析什么，串行解析并执行

文档解析的过程中，如果遇到`script`脚本，就会停止页面的解析进行下载（但是Chrome会做一个优化，如果遇到`script`脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载`script`所对应的资源，这样能够节省一部分下载的时间 `@Update: 2018-08-17`）。
资源的下载是在解析过程中进行的，虽说`script1`脚本会很快的加载完毕，但是他前边的`script2`并没有加载&执行，所以他只能处于一个挂起的状态，等待`script2`执行完毕后再执行。
当这两个脚本都执行完毕后，才会继续解析页面。

![image](前端.assets/31621391-39849b1a-b25f-11e7-9301-641b1bc07155.png)

defer

遇到 js 文件时，先并行下载，等到文档树解析完毕后，串行执行之前下载的 js 文件

文档解析时，遇到设置了`defer`的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&渲染完毕后。
会等到所有的`defer`脚本加载完毕并按照顺序执行，执行完毕后会触发`DOMContentLoaded`事件。

![image](前端.assets/31621324-046d4a44-b25f-11e7-9d15-fe4d6a5726ae.png)

async

遇到 js 文件后，先并行下载，然后那个下载完毕就执行哪个，所以执行的先后顺序是不确定的

`async`脚本会在加载完毕后执行。
`async`脚本的加载不计入`DOMContentLoaded`事件统计，也就是说下图两种情况都是有可能发生的

![image](前端.assets/31621170-b4cc0ef8-b25e-11e7-9980-99feeb9f5042.png)

![image](前端.assets/31622216-6c37db9c-b261-11e7-8bd3-79e5d4ddd4d0.png)

推荐的应用场景

defer

​		如果你的脚本代码依赖于页面中的`DOM`元素（文档是否解析完毕），或者被其他脚本文件依赖。

1.  评论框
2.  代码语法高亮
3.  `polyfill.js`

async

​		如果你的脚本并不关心页面中的`DOM`元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。

1.  百度统计

如果不太能确定的话，用`defer`总是会比`async`稳定







###### DOM加载顺序

  （1）解析html结构

  （2）加载外部脚本和样式表文件

  （3）解析并执行脚本代码

  （4）构造HTML DOM模型  

​			//DOMContentLoaded执行点，此时已经具有所有的Dom节点，适合使用js进行操作

  （5）加载图片等外部文件

  （6）页面加载完毕 

​			//load，此时已经加载完所有的Dom节点以及各种外部资源比如图片字体

总结，DOMContentLoaded 钩子函数时，所有的Dom已经就绪，也就是说此时已经可以使用js操作dom了，如果等到 load 钩子函数时再执行 js 操作，那么还得再等一段时间来加载 图片等外部资源，这将会降低用户体验

**JQuery中的 ready 和 load**

JQuery中有 

`$(document).ready(function(){...})`   对应 DomCententLoaded 钩子函数

`$(document).load(function(){...})`   对应 load 钩子函数





###### window对象

​		window 是客户端浏览器对象模型的基类，window 对象是客户端 [JavaScript](http://c.biancheng.net/js/) 的全局对象。一个 window 对象实际上就是一个独立的窗口，对于框架页面来说，浏览器窗口每个框架（iframe或者frame标签）都对应一个 window 对象

​		在js中定义的全局变量和全局函数，其实都是挂在了 window 对象上

```js
    var a = "window.a";  //全局变量，其实是加到了 window 对象上
    function f () {  //全局函数， 其实是加到了 window 对象上
        console.log(a);
    }
    console.log(window.a);  //返回字符串“window.a”
    window.f();  //返回字符串“window.a”
```

​		window对象是浏览器窗口的根对象，使用 window 对象可以访问客户端其他对象，这种关系构成浏览器对象模型，window 对象代表根节点，浏览器对象关系的关系如图所示，每个对象说明如下。

-   window：客户端 JavaScript 顶层对象。每当 <body> 或 <frameset> 标签出现时，window 对象就会被自动创建。
-   navigator：包含客户端有关浏览器信息。
-   screen：包含客户端屏幕的信息。
-   history：包含浏览器窗口访问过的 URL 信息。
-   location：包含当前网页文档的 URL 信息。
-   document：包含整个 HTML 文档，可被用来访问文档内容及其所有页面元素。

![img](前端.assets/6-1Z926112Q3550.gif)

​		另外，在js中可以直接使用的 alert 函数，confirm函数，setTimeout函数，setinterval函数等都是 window 对象上的方法，直接调用实际上是省略了 window. 的写法





###### [JWT( Json Web Token )](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案

​		传统 session_id 的方法能够很好地作用于单机服务器上，如果想要作用于分布式服务器上，就还需要考虑 session 共享的问题

**JWT的思路**

JWT思路是不再将验证信息存储到服务器上，而是存储到浏览器本地，发送请求时带上 JWT，在服务端对其进行验证

JWT就是一个字符串，包含三个部分 {header. payload. signature}，三个部分使用 . 符号隔开组成一个字符串



**Header** 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

上面代码中，`alg`属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；`typ`属性表示这个令牌（token）的类型（type），JWT 令牌统一写为`JWT`。

最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。



**Payload** 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用

>   -   iss (issuer)：签发人
>   -   exp (expiration time)：过期时间
>   -   sub (subject)：主题
>   -   aud (audience)：受众
>   -   nbf (Not Before)：生效时间
>   -   iat (Issued At)：签发时间
>   -   jti (JWT ID)：编号

除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分，如果要存放秘密信息，请使用 https 的方式传输 JWT

这个 JSON 对象也要使用 Base64URL 算法转成字符串。



**Signature** 部分是对前两部分的签名，防止数据篡改。

首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

```javascript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```



**这里的原理是，**

密钥只有服务端知道，那么使用密钥对前面两部分进行加密，得到签名

如果用户私自更改了前面两部分，而用户又不知道密钥，那么等待服务器收到 JWT 后，会使用密钥对前两部分进行加密，得到签名，然后与第三部分的签名对比，如果相同，则代表前面两个部分没有被篡改，反之则认为前两部分无效， JWT 无效



客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

然后请求服务器时，带上这个 JWT， 可以放到HTTP 请求的头信息`Authorization`字段里面，也可以放到 cookie 里面发送，也可以放到 Post请求体中发送



**JWT的大缺点，**

服务端不保存 session 状态，那么一旦发配了一个 JWT，在其指定的失效时间之前，将不能使其失效，所以 JWT 的失效时间应当适当地设置小一点





###### [AJAX](http://javascript.ruanyifeng.com/bom/ajax.html)

​		1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。所以说白了，就是在这之后，可以使用 js 请求服务器，然后得到服务器的响应结果，最后根据响应结果执行 js 操作 dom修改界面，而在这之前，想要修改界面中的内容，只能通过向浏览器导航栏中重新输入 url 然后回车刷新整个页面来实现。

​		2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过  JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX  这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。

​		通过上面可以得知，Ajax 的实现方式，无非就是调用 js 提供的网络请求接口，这个接口就是 `XMLHttpRequest` 对象

具体来说，AJAX 包括以下几个步骤。

1.  创建 XMLHttpRequest 实例
2.  发出 HTTP 请求
3.  接收服务器传回的数据
4.  使用js通过操作 dom 更新网页内容

那么，现在只需要了解 js 中提供的 `XMLHttpRequest` 接口 Api 即可

通常是

```js
// 1. 新建一个xhr实例
var xhr = new XMLHttpRequest();
// 2. 设置下请求方法和url
xhr.open('GET', 'http://www.example.com/page.php', true);
// 3. 设置xhr一些属性和回调函数
xhr.onreadystatechange = function(){
  // 通信成功时，状态值为4
  if (xhr.readyState === 4){
    if (xhr.status === 200){ // 状态码200代表请求成功，进而解析数据
      console.log(xhr.responseText);
    } else {
      console.error(xhr.statusText);
    }
  }
};
xhr.onerror = function (e) {
  console.error(xhr.statusText);
};
// 4. 使用 send函数 真正发出请求
xhr.send(null);
```





###### [同源政策](http://javascript.ruanyifeng.com/bom/same-origin.html)

所谓“同源”指的是”三个相同“。

>   -   协议相同
>   -   域名相同
>   -   端口相同

目前，如果非同源，共有三种行为受到限制。

>   （1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
>
>   （2） 无法接触非同源网页的 DOM。
>
>   （3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

**目的**

​		同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

​		设想这样一种情况：A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个  Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的  Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie  往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。

​		由此可见，同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。

**规避 Ajax 同源限制**

>   -   JSONP ：使用js动态向 dom 中添加 script 标签，然后指定 src为目标接口，并指定回调函数参数，服务端将数据作为回调函数的参数传递回来，js 收到返回后直接执行回调函数，获得的参数即目标数据
>
>   -   WebSocket ： 本身无同源限制
>
>   -   [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html) : 
>
>       ​		一开始的同源政策限制了 Ajax 可访问的服务只能是同源服务器，但是随着前后分离的开发场景，确实需要 Ajax 可以访问非同源服务器的功能，于是，就制订了 CORS 这个标准，使用这个标准流程，可以安全地进行非同源的 Ajax 访问
>
>       
>
>       对于简单请求，
>
>       首先是浏览器在请求头带上 Origin 参数，代表来自哪个源的请求，
>
>       然后服务器端对该源进行判断，如果在允许列表中，则返回 Access-control 的一系列字段，表示同意该 Ajax 请求，同时正常返回数据，
>
>       浏览器收到正常的返回后即解析数据，完成 Ajax
>
>       
>
>       对于非简单请求，得进行两次请求，
>
>       首先是浏览器发送一个 Options 类型的请求，此次请求称为 “预检” 请求，在请求头带上 Origin 参数，代表来自哪个源的请求，
>
>       然后服务器端对该源进行判断，如果在允许列表中，则返回 Access-control 的一系列字段，表示同意该 Ajax 请求，
>
>       注：如果服务器不同意该请求源，会触发 xhr 对象的 onerror事件，收到这样的错误
>
>       ```
>       XMLHttpRequest cannot load xxx
>       Origin xxx is not allowed by Access-Control-Allow-Origin.
>       ```
>
>       浏览器收到服务器的确认后，再次发起原先的请求，
>
>       服务器返回正常的数据，
>
>       浏览器解析数据完成 Ajax
>
>       在 CORS 流程中，这些操作对于用户来说都是透明的，不可见的，开发人员只需要在服务端设置允许非同源即可
>
>       
>
>       使用了CORS方法，就可以安全地进行非同源的 Ajax了，但是此时 cookie 还是不能发给非同源，所以就又有一种方案（规定），
>
>       首先在 xhr 请求中显式设置 withCrendiente=true，此时发起非同源请求时浏览器会带上 cookie，
>
>       然后在服务端设置 Access-Control-Allow-Creditials=true， 此时服务器同意接收来自非同源的 cookie，
>
>       这样下来，就能通过使用 cookie 完成用户的认证功能







###### [盒模型](https://www.runoob.com/css/css-boxmodel.html)

![CSS box-model](前端.assets/box-model.gif)

css中设置的 width 和 height 其实是 <span style='color:cyan;'>content</span> 的 宽度 和 高度

所以

盒模型的总宽度 = 宽度+左填充+右填充+左边框+右边框+左边距+右边距

盒模型的总高度 = 高度+顶部填充+底部填充+上边框+下边框+上边距+下边距

但是

IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和

要兼容

就不要设置 padding 和 margin，再套一个父容器来实现



###### [flex](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

容器属性

>   -   flex-direction	元素排列方向
>   -   flex-wrap    超出一行是否换行
>   -   flex-flow    前两个的缩写
>   -   justify-content    元素在主轴上的对齐方式
>   -   align-items    元素在副轴上的对齐方式
>   -   align-content    多根轴线时，它们的对齐方式

元素属性

>   -   `order`    元素排列优先度
>   -   `flex-grow`    有空余空间时扩张
>   -   `flex-shrink`   空间不足时压缩
>   -   `flex-basis`    指定固定长度/宽度
>   -   `flex`    前面三个缩写
>   -   `align-self`   单独指定其在主轴上的对其方式，覆盖容器的 align-item 设置









