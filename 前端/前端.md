[语义化标签](https://segmentfault.com/a/1190000013901244)

[input标签类型](https://blog.csdn.net/qq_36171618/article/details/80802588)

[flex](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

[伪类和伪元素](https://www.jianshu.com/p/c7dcb3008e5c)

[元素水平垂直居中](https://www.cnblogs.com/linsinan/p/6132241.html)

[position属性值](https://blog.csdn.net/weixin_44589540/article/details/115400664)

[css选择器](https://blog.csdn.net/lucky541788/article/details/81625347)

[回流和重绘](https://www.cnblogs.com/youguo2/p/10933043.html)



[js数据类型](https://www.runoob.com/js/js-datatypes.html)

[null和undifined区别](https://www.cnblogs.com/shengmo/p/8671803.html)

[Symbol](https://www.runoob.com/w3cnote/es6-symbol.html)

[js原型](https://www.jianshu.com/p/72156bc03ac1)



###### http协议

无状态，客户端/服务器模式，快速响应的设计，同时存在安全问题

<span style='color:cyan;'>请求格式</span>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>方法</div>	<div style='display:inline-block;padding:5px;background:blue;color:black;'>URL</div>	<div style='display:inline-block;padding:5px;background:pink;color:black;'>版本</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>...</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>请求体内容</div>



<span style='color:cyan;'>响应格式</span>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>版本</div>	<div style='display:inline-block;padding:5px;background:blue;color:black;'>状态码</div>	<div style='display:inline-block;padding:5px;background:pink;color:black;'>状态码描述</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:green;color:black;'>key</div>	<div style='display:inline-block;padding:5px;background:orange;color:black;'>value</div>	<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>...</div>

<div style='display:inline-block;padding:5px;background:gray;color:black;'>CRLF</div>

<div style='display:inline-block;padding:5px;background:orange;color:black;'>响应体内容</div>





###### CRLF注入

​		因为在请求数据中，它是根据CRLF，也就是 \r\n 来表示某一行的结束，那么用户就可以恶意的在 URL 后面手动加上 CRLF ，然后再加一些恶意的 key：value，这样服务端就会解析到恶意的 key：value，从而造成安全问题

​		解决方法是在服务端对请求数据进行清理，去掉不符合规范的 CRLF 字符





###### http调优

http请求基于tcp连接来通信，首先是得两台要通信的计算机建立tcp连接，

然后在该连接上发送和接收数据，

<span style='color:yellow;'>*长连接*</span>

​		http请求具有短暂和突发的特点，也就是定不准什么时候就突然请求一下资源

那么如果每次要发送http请求时，都重新建立tcp连接，那么就得每次都经历三次握手和四次挥手的申请内存和释放内存的活动，这样时间将都被浪费在这里，

所以，应当使用长连接的方式，复用同一个tcp连接，多次进行http请求，这样就初步提高了http的性能，该方案就是 http1.1 做出的改进

<span style='color:yellow;'>*tcp慢启动*</span>

​		但是还存在一个问题，就是tcp连接存在慢启动机制，还记得在linux中的tcp设置吗？其中有一个设置是发送和接收窗口的大小，这里设置的是一个范围，也就是刚建立连接时，设置窗口大小为初始值，然后根据网络情况不断增大至最佳性能，这个设计的目的是避免多个tcp连接一上来就发送大的数据包从而造成路由器缓存被占满从停止响应的问题，这就是慢启动机制

显然，http请求属于时不时来一下子的数据交互，因为慢启动机制的存在，http请求将总会吃到最开始的慢速度，所以最直接的方式就是关闭linux中tcp设置的慢启动功能

就像这样关闭了，就可以很直接地提升http请求的用户体验

![image-20210915212640832](前端.assets/image-20210915212640832.png)

<span style='color:yellow;'>*拥塞窗口的初始值*</span>

​		看完了tcp慢启动问题，显然，我们也可以通过把拥塞窗口的初始值大小设置得大一些来直接提高http的用户体验





###### http版本差别

1.0

短连接，一个http请求建立一个tcp链接

只定义了 get， post， head 三种

1.1

支持六种 get，post，head，delete，put，options

长连接，一个tcp连接一直用来进行http请求和响应，直至http请求中设置 connection: close，但是这些http请求是串行地使用这个tcp连接

2.0

多路复用tcp连接，也就是在一个tcp连接中可以同时发送多个http请求和响应，它们根据不同的id号区分

客户端和服务端同时保存head cache，那么在发送http请求时，不再需要发送重复的请求头参数，只需要增量发送请求头参数即可

使用二进制的方式传递数据，也就是数据都使用01的方式传递，这样就避免了字符传递时大部分的错误，之前都是字符文本传输

支持服务端主动向客户端发送数据了

数据压缩传输，这样更节省带宽





###### [XSS攻击](https://zhuanlan.zhihu.com/p/26177815)

先上一段标准解释（摘自百度百科）。

>   “XSS是跨站脚本攻击(Cross Site  Scripting)，为不和层叠样式表(Cascading Style Sheets,  CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。”

相信以上的解释也不难理解，但为了再具体些，这里举一个简单的例子，就是留言板。我们知道留言板通常的任务就是把用户留言的内容展示出来。正常情况下，用户的留言都是正常的语言文字，留言板显示的内容也就没毛病。然而这个时候如果有人不按套路出牌，在留言内容中丢进去一行

```js
<script>alert(“hey!you are attacked”)</script>
```

那么留言板界面的网页代码就会变成形如以下：

```html
<html>
    <head>
       <title>留言板</title>
    </head>
<body>
<div id=”board” 
        <script>alert(“hey!you are attacked”)</script>
</div>     
    </body>
</html>
```

那么这个时候问题就来了，当浏览器解析到用户输入的代码那一行时会发生什么呢？答案很显然，浏览器并不知道这些代码改变了原本程序的意图，会照做弹出一个信息框。

其实归根结底，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。

**XSS攻击能做什么**

*   **窃取网页浏览中的cookie值**

    ```js
    document.cookie
    ```

*   **劫持流量实现恶意跳转**

    ```js
    <script>window.location.href="http://www.baidu.com";</script>
    ```

**如何绕过XSS检查**

*   **大小写绕过**

    >   http://192.168.1.102/xss/example2.php?name=<sCript>alert("hey!")</scRipt>

*   **利用过滤后返回语句再次构成攻击语句来绕过**

    删一个 script 标签，还剩一个 script 标签

    >   http://192.168.1.102/xss/example3.php?name=<sCri<script>pt>alert("hey!")</scRi</script>pt>

*   **利用其他标签的事件来插入代码**

    >   http://192.168.1.102/xss/example4.php?name=\<img
    >   src='w.123' onerror='alert("hey!")'>

*   **用eval执行编码后的代码**

    例如alert(1)编码过后就是

    ```text
    \u0061\u006c\u0065\u0072\u0074(1)
    ```

    所以构建出来的攻击语句如下：

    >   [http://192.168.1.102/xss/example5.php?name=eval(\u0061\u006c\u0065\u0072\u0074(1))](https://link.zhihu.com/?target=http%3A//192.168.1.102/xss/example5.php%3Fname%3D%3Cscript%3Eeval(/u0061/u006c/u0065/u0072/u0074(1))%3C/script%3E)

**XSS攻击大致上分为两类：**

>   一类是反射型XSS，又称非持久型XSS，
>   一类是储存型XSS，也就是持久型XSS。

**什么是反射型XSS**

其实，我们上面讲XSS的利用手段时所举的例子都是非持久型XSS。

也就是攻击相对于访问者而言是一次性的，具体表现在我们把我们的恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。

也就是说想要触发漏洞，需要访问特定的链接才能够实现。

**什么是储存型XSS**

它与反射型XSS最大的不同就是服务器再接收到我们的恶意脚本时会将其做一些处理。

例如储存到数据库中，然后当我们再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。

还记得在文章开头提到的留言板的例子吗？那通常就是储存型XSS。当有人在留言内容中插入恶意脚本时，由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪。

这个过程一般而言只要用户访问这个界面就行了，不像反射型XSS，需要访问特定的URL。

**防范手段**

-   首先是过滤。对诸如<script>、<img>、<a>等标签进行过滤。
-   其次是编码。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。
-   最后是限制。通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。
