# JVM

***JVM***

```english
	A JVM implementation is a computer program that meets the requirements of the JVM specification. An instance of a JVM is an implementation running in a process that executes a computer program compiled into Java bytecode.
```

***JRE***

```english
	Java Runtime Environment (JRE) is a software package that contains what is required to run a Java program. It includes a Java Virtual Machine implementation together with an implementation of the Java Class Library. 
```

***JDK***

```
	Java Development Kit (JDK) is a superset of a JRE and contains tools for Java programmers, e.g. a javaccompiler. 
```



>   JVM本质就是一个程序
>
>   用来运行java代码 (不是, 只要能够编译成.class文件的语言代码都可以)
>
>   ​	所以说是 , 一次编译, 处处解释, 到哪还得用这个jvm来解释, 然后还得保证解释的时候有第三方包, 要不然结束不通
>
>   JVM本质是解析.class字节码指令的程序





#### 内存结构



![image-20210714162645771](jvm.assets/image-20210714162645771.png)



##### 程序计数器(PC Register)

> java源码 --编译--> 二进制字节码(jvm指令) --解释器--> 机器码 ----> cpu执行
>
> 在解释器对 jvm 指令进行翻译时, 程序计数器存放下一条 jvm 指令的位置, 解释器执行完一句jvm指令后 , 会去程序计数器中读取下一条指令的地址.
>
> 程序计数器的本质就是一个寄存器
>
> 程序计数器是线程所私有的 : java支持多线程, 即同时在多个线程中执行不同的代码, 每一个线程都私有地拥有一个程序计数器, 当线程用完cpu分配给它的时间片后, 会将当前程序运行到的位置存到自己私有的程序寄存器中, 待到再次得到执行权, 就从自己的程序计数器中获取到程序运行的位置继续运行.



##### 栈

###### 虚拟机栈(JVM Stacks)

> 程序开启的线程在执行代码时实际上就是在执行一个个的方法, 而这些方法都需要一段内存来存放参数和变量, 虚拟机栈就是用于存放每个方法的参数和变量的一个栈.
>
> 在虚拟机栈中, 每当执行一个方法, 就会生成一个 栈帧 用于存放该方法的参数和变量 , 并将这个 栈帧 放入栈中, 当方法执行完毕后, 这个栈帧就会出栈.
>
> 在栈顶部的 即正在执行的方法, 被称为 活动栈帧
>
> 在 idea 中, 以debug的方式运行代码, 在执行某个方法的调用之前断点, 逐行执行代码 ,会在debug面板中的 Frames 选项卡中查看到 栈帧的入栈和出栈的过程

虚拟机栈的特点

> 垃圾回收不需要管这个栈, 因为它会随之方法的执行自动地入栈和出栈
>
> 可以通过 -Xss< size > 运行参数来设置栈的大小 , idea 中就是运行设置里的 vm options
>
> 栈内存不宜过大, 因为内存总大小就那么大, 栈内存大了, 可以开的线程数就少了, 这样就会影响到运行的效率

栈内存机制涉及的线程安全问题:

> 方法内的变量是线程安全的, 就是如果有多个线程在同时调用这个方法, 那么它们会在各自的栈中创建各自的一份 栈帧, 这些栈帧都是独立的, 所以不会影响到其他栈中的栈帧.  
>
> 但是全局的静态变量是线程不安全的, 因为多个线程每次都要从全局来读取它, 这样就会造成数据的读写混乱.
>
> 如果方法内的变量是引用类型且仅仅在方法内自己玩 , 也就是随着方法的调用结束而被回收, 那么它是线程安全的, 但是如果它的不是仅仅在方法内自己玩, 它就不是线程安全的

栈内存溢出:

> 1. 栈帧过多会导致栈内存溢出 , 例如没有结束条件的递归
> 2. 栈帧过大会导致栈内存溢出



###### 本地方法栈

> 有些与操作系统交互的方法仅靠java无法实现,所以需要调用一些 c 或者 c++ 实现的方法, 这些方法被称为本地方法, 使用 native 修饰 
>
> 本地方法栈就用来提供本地方法运行时所需要的内存空间



##### 堆

###### 对象实例

> 通过new 创建的对象都会放到堆中
>
> 堆中的数据都是线程共享的
>
> 堆中的数据会被gc回收
>
> 可通过运行参数 -Xmx< size > 来设置

堆内存溢出

> 在对象不被回收的情况下, 无限创建对象 会导致堆内存溢出

###### 常量池

> 用于存放java程序编译成为 class 对象后每一步java指令所使用的 值

###### stringtable

> stringtable 就是用来存放字符串常量的
>
> 每当出现一个新的字符串常量时, 就生成一个新的串存到串池里, 下次在使用字符串常量时, 先在串池中查找, 有则直接使用, 没有就创建新的放入stringtable

> 在版本1.6中, 串池( stringtable )位于常量池
>
> 在版本1.6以后, stringtable 位于堆内存中 , 因为堆的垃圾回收更加频繁, 能够减少字符串常量所占的内存

> 在java代码中通过调用 String类型变量的 intern() 方法手动将该String对应的字符串存到 StringTable中, 然后返回该字符串在 stringtable 中的地址
>
> 在 1.6 中, 调用 intern() 方法时, 会复制一份字符串常量存到stringtable中
>
> 在 1.8 中, 调用 intern() 方法时, 直接将该String对象的地址存到stringtable中 

stringtable调优

> stringtable的数据结构是hash表, 即总共有 n 个 bucket, 每一个 bucket中以链表的方式 存放一定hash范围内的数据
>
> 这个总的 bucket 的个数越多, 也就是hash分段越细, 那么在向 stringtable 中添加新的 字符串常量时就越容易找得到它应当被存到哪个 bucket 中, 从而存储效率也就越高.
>
> 所以如果有很多个 字符串常量要存储在 stringtable 中时, 适当的增大 bucket 个数, 能够提高数据存储的效率
>
> 通过运行参数 -XX:StringTableSize=200000 来设置 bucket 的个数

stringtable的应用

> ⭐ 假设有大量的字符串数据, 其中有不少是重复的, 现在要在程序中将它们存储到一个 List 中
>
> 1️⃣ 如果使用 new String 的方式来创建它们, 那么这些字符串会一个不差地被创建为新的 String 对象被存到堆中
>
> 2️⃣ 如果将这些字符串 通过调用 intern() 放入 stringtable 中, 然后将该方法返回的值即它在 stringtable 中地址存到 List 中, 因为 stringtable 不会存重复数据的特性, 所以这就相当于使用了更少的空间存储了更多的数据, 极大地降低了内存的使用 







##### 方法区

> 存放类的字段, 方法 和 运行时常量池
>
> ​	注: 1.6及以前, 常量池在方法区, 1.7常量池在堆, 1.8及以后常量池在元空间(其实还是方法区,又挪回来了)
>
> 1.8以前叫 永久代, 1.8以后叫 元空间
>
> 在java1.8及以后, 该区域直接使用物理内存空间, 就是主机的内存
>
> java1.8 以及以后 , 通过运行参数 -XX:MaxMetaspaceSize=8m 来设置大小
>
> java1.8 以前 , 通过运行参数 -XX:MaxPermSize=8m 来设置大小







##### 直接内存

> 这一部分的内存来自物理内存, 不属于分配给 java 程序的内存
>
> 一般用于 nio 读写文件操作时的缓冲区域
>
> 调用 ByteBuffer.allocateDirect(_1GB); 可从操作系统获得对应大小的物理内存
>
> ( 不推荐, 这个方法一般是jdk内部自己调用 )或者调用 Unsafe 类型实例的 allocateMemory(_1Gb) 获取直接内存
>
> 回收时调用 Unsafe 实例的 freeMemory() 方法
>
> ByteBuffer.allocateDirect() 实际上也是调用了 Unsafe 的 allocateMemory() 方法, 然后由 Cleaner 虚引用来监测 ByteBuffer 的状态, 当 ByteBuffer 被回收时, cleaner 调用 freeMemory() 方法实现释放直接内存

> 在运行参数中设置 -XX:+DisableExplicitGC 禁用在代码中显式地调用垃圾回收,即 System.GC() , 这样会造成直接内存不会被释放直到对应的变量被销毁, 此时可以通过调用 unsafe 对象的 freeMemory() 实现对直接内存的回收



#### 垃圾回收

##### 如何判断对象是否可以回收

1. 引用计数法

   ​	就是当对象被引用时计数加一, 失去被引用计数减一, 当引用数为零时, 意味着它可以被回收

   ​	但是如果存在两个对象的相互引用, 那么这两个对象就永远不会被垃圾回收

   ​	jvm中不采用此种回收机制

2. 可达性分析算法

   ​		先确定根对象,即GC Root对象, 然后查看目标对象是否被根对象所引用, 如果没有被根引用则可以作为垃圾进行回收

   ​		jvm中使用这种回收机制
   
   ​		a, b 对象可回收，就一定会被回收吗?并不是，对象的 finalize  方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行  finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC  会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！
   
   ​		**注意：** finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!





##### 四种引用类型

1. 强引用

   ​	一般在代码中创建的对象都是强引用类型

   ​	通过 new 新建的对象然后通过 = 赋值给一个变量, 这种就被成为强引用, 只要某一对象存在被 gc root 对象强引用, 就不会被垃圾回收

   ​	专业来说, 只要在栈里面存在对堆对象的引用, 就是强引用

2. 软引用

   ​	在垃圾回收之后仍然内存不足时, 会发起对软引用对象的回收, 在代码中通过 new SoftReference() 来创建软引用对象,

   ​	创建软引用对象时可通过传参指定绑定一个 引用队列, 当软引用对象引用的对象被回收时, 该软引用对象会被加入到 引用队列中, 此时可通过引用队列中的元素来回收指定的软引用对象

3. 弱引用

   ​	在垃圾回收时不管内存紧不紧张都会被回收的引用类型, 在代码中通过 new WeakReference() 或者 new WeakHashMap() 来创建

   ​	同 软引用 可配合引用队列来实现 对引用对象本身的记录和清理

   ​	WeakHashMap 和 HashMap 的区别就是 弱引用 和 强引用

4. 虚引用

    ​	软引用对象和弱引用对象在失去引用而将要被回收时, 不是直接回收, 而是加入引用队列, 待到下次gc, 直接从引用队列里出队然后才回收

    ​	如果想要观测其他对象的回收时机, 或者在它们回收之前做一些操作, 那么使用虚引用, 虚引用被创建时就直接加入引用队列, 在执行gc前如果是队头那么会提前出队, 此时会收到通知, 就可以在此处添加操作

5. 终结器引用



##### 垃圾回收策略

> 三种方法在 jvm 中分不同的情况都有使用

###### 标记清除

先看看对象是否与 GC Root 对象有引用关系 , 如果没有, 那么就把这个对象占用的起始和终止位置记录到空闲内存列表中, 供新对象创建时查询并使用

优点: 快

缺点: 会产生内存碎片

###### 标记整理

先看看对象是否与 GC Root 对象有引用关系 , 如果没有, 那么就把这个对象占用的位置标记为空闲, 然后将内存中其他对象使用这些空闲位置进行紧凑整理, 结果就是没有了内存碎片

优点: 没有内存碎片

缺点: 慢

###### 复制

将整个内存分为两个大小相同的区域 , 分别为 from 和 to, 其中只用 from 来存对象, to 保持为空, 当垃圾回收时, 先根据 GC Root 的引用关系对对象进行是否被回收的标记, 然后将存活的对象都复制到 to 区中, 随后清空 from 区, 最后交换 from 和 to 的名字

优点: 没有内存碎片, 相对标记整理快

缺点: 浪费内存



###### 分代垃圾回收

​		分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起

`Eden区：幸存区from：幸存区to = 8：1：1`

`新生代：老年代=1：2`

<img src="jvm.assets/image-20210818123438883.png" alt="image-20210818123438883" style="zoom:67%;" />

***分代垃圾回收的流程***

![图片](jvm.assets/minorGC)

1.  新创建的对象保存到 伊甸园区 中

2.  伊甸园满了时, 触发 minor gc 垃圾回收

    存活的对象、幸存区from中的对象 复制到 幸存区 to 中, 并且标记它的寿命加一 

    如果寿命已经大于老年代阈值，移动到老年代

    最后清空伊甸园

    交换 幸存区from 和 幸存区to

> ​		当老年代满了时 , 触发对整个内存的 full gc 垃圾回收（stw） , 本次回收完后, 如果发现内存还是不够, 那么会抛异常 outofmemory

> ​		gc时, 为防数据混乱, 会暂停其他线程只运行垃圾回收这个线程

> ​		对于大小超过了新生代总容量的对象, 如果老年代能存下, 直接存到老年代中

> ​		子线程内发生的内存溢出不会影响主线程的正常运行

**空间分配担保**

​		在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间

​		如果大于，那么Minor GC  可以确保是安全的

​		如果不大于，那么虚拟机会查看 HandlePromotionFailure  设置值是否允许担保失败

​		如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小

​		如果大于则进行 Minor  GC，否则可能进行一次 Full GC。

**Stop The World**

​		如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。

​		什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。

<span style='color:lightblue;'>*画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。*</span>

​		一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理**整个堆**中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！

​		所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的  STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）

​		由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe  Point，这个时间点的选定既不能太少以让 GC  时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。

​		一般当线程在这个时间点上状态是可以确定的，如确定 GC Root  的信息等，可以使 JVM 开始安全地 GC

![1595149937053](1595149937053.png)



##### 垃圾回收器的种类

###### 串行垃圾回收器

> 通过设置虚拟机参数启用 -XX:+UseSerialGC=Serial+SerialOld

* 单线程执行垃圾回收任务
* 适合堆内存较小时的情况, 就一个线程在这干活, 堆内存太大了得回收很长时间, 适合单核的cpu, 因为单核cpu只能开一个线程

如果在多核机器上使用了串行垃圾回收器, 那么流程如下:

![1595151873899](1595151873899.png)

###### 并行垃圾回收器

> 通过设置虚拟机参数启用 -XX:+UseParallelGC 开启该回收器 , 在 jdk1.8中默认使用这个
>
> 通过设置参数设置使用的线程数: -XX:ParallelGCThreads=n

* 多线程执行垃圾回收
* 适合多核cpu , 因为只有多核才能真正开多个线程, 从而提高效率
* 策略是让单位时间内, 执行垃圾回收时其他线程停止的时间尽量短, 从全局考虑问题

垃圾回收时的流程:

![1595152054920](1595152054920.png)

###### CMS回收器(并发标记清理)

> 通过设置参数开启该回收器 -XX:+UseConcMarkSweepGC
>
> 响应时间优先

* 多线程执行垃圾回收
* 适合多核cpu
* 策略是让单次垃圾回收时, 其他线程停止的时间尽量短, 仅着眼于眼前考虑问题

<span style='color:cyan;'>CMS回收器与并行垃圾回收器的区别</span>在于, 并行垃圾回收器进入gc时, 就从标记到清理一套执行完毕才结束, 而CMS把标记和清理分离, 且部分标记操作是并发执行的, 清理工作也是并发执行的, 这样就提高了程序的响应时间, 不会因为需要等待完整的gc时间而停顿很久

<span style='color:pink;'>垃圾回收的流程</span>

1.  <span style='color:cyan;'>初始标记</span> : 单开一个垃圾回收线程标记工作线程中直接引用的对象, 此时工作线程阻塞
2.  <span style='color:cyan;'>并发标记</span> : 垃圾回收线程与工作线程并发执行, 垃圾回收线程根据上一步标记出引用到的对象, 对所有对象进行遍历, 以确定哪些对象需要被清理
3.  <span style='color:cyan;'>重新标记</span> : 由于上一步中并发执行的工作线程可能导致对象引用的变化, 为了防止清理掉还在被引用的对象, 这一步中多个垃圾回收线程并发遍历变更引用对象所关联的对象, 以更新哪些对象应当被清理
4.  <span style='color:cyan;'>并发清理</span> : 此时, 已经正确标记出当前状态下哪些对象需要被清理, 垃圾清理线程与工作线程并发执行, 垃圾清理线程进行对象回收

![1595152580893](1595152580893.png)

###### G1 垃圾回收器

> 一种同时注重吞吐量和低延迟的回收器
>
> 在 jdk9 及之后为默认的垃圾回收器
>
> 通过设置参数 -XX:+UseG1GC 使用该垃圾回收器

​	将堆内存分为离散的region(格子), 每个格子都有不同的角色(eden, servivor, old), 清理过程依然是标记, 复制, 清理

​	垃圾清理线程和工作线程是并发执行的, 所以能够低延迟



##### gc时间过长卡顿?

1.  优化代码, 少new一些对象
2.  新生代内存分的太少, 总是发生 minor gc, 然后其中的对象寿命也增加的很快, 导致它们很快就进入老年代, 然后等到 full gc 的时候就得花更多时间
3.  GC算法不行, 换一个
4.  jvm进程内存被swap到交换内存里, 那么此时gc的就是硬盘, 会很慢
5.  GC线程太少
6.  调用了太多的 System.gc(), 这个是 full gc
7.  堆内存太大, 所以gc很耗时





#### 类加载

> 编译时将 java 文本文件编译成 class 文件
>
> 运行时首先需要将 class 文件中的类加载到内存方法区, 以便之后的使用

###### class文件的结构

> 详情可查看 oracle 官方 jvm规范

> class 文件的结构应当遵循 jvm 规范, class文件使用十六进制表示
>
> class 文件中各个位置的数据代表含义如下
>
> 其中 u4, u2 代表4个字节和2个字节(一个字节是二进制八位, 这里是十六进制, 所以一个字节就是一对挨着的数字)

![1595318622045](1595318622045.png)

> class 文件的前四个字节 : 魔数 , 用来表示它是否是 class 类型的文件 , 不同的 魔数 代表不同类型的文件, class 文件的 魔数 是 cafe babe

![1595318771907](1595318771907.png)

> 接下来四个字节是 版本号

![1595318887766](1595318887766.png)

> 常量个数

![1595318981831](1595318981831.png)

> 接下来就是各个常量的具体数据

> 其中每一个常量的前两位代表该常量的类型, 对应关系如下表
>
> 常量的存储格式 : 常量类型(一个字节) + 常量长度(两个字节) + 常量数据(常量长度值的字节数)

![1595319140706](1595319140706.png)

> 例如

![1595319210925](1595319210925.png)

> 访问标识
>
> 访问标识对应关系如下表

![1595319976990](1595319976990.png)

> field成员变量
>
> 成员变量类型对应如下表

![1595320087839](1595320087839.png)

###### 反编译 class 文件

>   使用javap 反编译 class 文件

```
// -v 代表同时编译常量池信息
# javap -v xxx.class
// 接下来会显示该 class 文件的结构信息
```

###### 指令集方法执行流程

> 字节码文件中的 字节码指令 对应一套 指令集 , 这套指令集只是为了方便人们理解的一种表示方式

1. 将常量池的内容加载到 运行时常量池中

2. 将用到的类加载到 堆内存 中

3. 将方法代码转换成为 指令集, 加载到 方法区

4. 开始执行方法时, 执行引擎创建一个 帧栈 来执行该方法, 每一层方法的调用都会为其创建一个帧栈 

   该帧栈包括 :

   参数槽 : 用来存放参数和变量 , 其个数事先根据方法计算得出

   操作栈 : 用来执行数据的操作 , 先将数据加载到操作栈中, 然后在其中进行运算

5. 参数和变量保存到 参数槽 中, 进行运算时就把数据加载到 操作栈中 进行操作

![1595323691980](1595323691980.png)

> 关于 ++ 操作:
>
> ++ 操作是可以直接在参数槽上执行的指令
>
> a++ 和 ++a 的本质区别在于, 是先将数据加载到操作栈中然后再在参数槽上自增 , 还是先在参数槽上自增然后再加载到操作栈中

> 条件判断指令 和 循环控制指令 :
>
> 本质上是先使用判断指令得到结果, 然后使用 goto 指令跳转到代码的指定行
>
> while 和 for 的字节码指令实际上一模一样

###### cinit初始化

> 编译器会将代码中的静态代码部分整合为一个方法, 这个方法被称为 cinit 方法, 在执行常规的方法代码前执行该方法

###### init初始化

> 在类的初始化时, 会首先将类内的 {} 代码块和对成员变量的赋值整合成一个方法, 这个方法被称为 init 方法, init 方法会在 类的构造方法 之前调用

###### try/catch/finally 的实现

> 带有 try/catch 的代码会在编译后生成一个 exception table ,用于记录那些行的执行结果需要被监控是否出现了指定的异常, 有则 goto 跳转到 catch代码块编译后的指令行

> finally 实际上是在编译过程中, 将 finally 代码块中的内容复制了三份分别放到了 try 代码块后面, catch 代码块后面 , catch 为捕获类型的异常代码后面

> 如果在 finally 代码块中包含了 return 语句, 那么编译为字节码指令后将不会生成 athrow 指令(抛异常), 同时使用 finally中的return作为返回标准, 即使 try 中也包含 return语句, 所以***不要***在finally 代码中写 return 语句, 会导致异常被吞掉

#### 类加载器

###### 类加载器做什么?

​	JVM运行class文件, 需要先将其中的类加载到方法区, 之后才能在运行代码时找到这些类然后创建实例, 类加载器就是将class文件中的类读取到方法区.

###### JVM自带的类加载器?

​	JVM里面自带了 Bootstrap ClassLoader , Extention ClassLoader, Application ClassLoader, 用来加载java核心类, java扩展类, 自定义引用的第三方类, 它们自右向左依次继承, JVM在运行之初, 就把这些类加载到了方法区

###### JVM类加载器的逻辑?

​	JVM 的类加载机制: 首先获取到指定的类加载器, 然后交给其父类加载器处理, 一直向上, 直至到达最基础的 Bootstrap ClassLoader , 如果某个父加载器无法加载, 就使用当前类加载器加载, 所以类加载器实际上就是一段代码, 大致逻辑就是通过io流读取class文件, 然后将读取到的字节流转换为类的定义, 然后将类定义放到方法区.

###### 自定义类加载器的作用?

1.  同时加载同一个类的多个版本

​	但是, 如果要同时加载多个相同的类, 那就无法实现, 因为它们的全限定类名相同, 而且类加载器相同, 所以在加载的时候一看两个一样, 那么就只会加载一个 

​	如果想要同时加载多个全限定类名相同的类, 可以使用自定义的类加载器来加载, 因为JVM判断两个要加载的类是否完全相同的依据是 `全限定类名+使用什么类加载器加载` , 所以使用不同的类加载器加载, 就可以实现同时加载多个完全相同的类

​	这在大型项目中很有用处, 因为多个第三方可能同时依赖了同一个包的多个不同版本, 如果直接使用 JVM的默认类加载, 那么这些类不能同时加载, 就可能出现 `NoSuchMethod` 错误

2.  热加载

​    每当业务代码中的类更新时, 就需要对内存中业务代码部分进行更新吧? 此时就需要调用它的类加载器更新内存上的对应部分

​	如果使用默认的类加载器, 那么会将整个项目都重新加载一次, 而业务代码往往在项目中占比是很小的, 因为很小的改动就需要重新加载整个项目到内存上, 这无疑是在浪费时间 

​	高效的做法是使用自定义的类加载器, 在其中只加载业务代码部分, 然后在项目启动时开一个线程, 监听业务代码的改动, 每当业务代码有改变时, 就执行自定义的类加载器只更新内存中业务代码部分, 这样就省去了大量时间, 也就实现了热加载.

3.  给class文件加密

​    通常情况下, 因为从 .java 文件到 .class 文件都遵守严格的 jvm 规则, 那么也可以根据这个规则, 从 .class 反编译得到 .java 文件 

​	如果不想让别人得到源码, 就需要对 .class 进行加密, 但是 jvm显然是不能识别加密后的 .class 文件的, 因此可以先把 .class 根据自己的规则加密, 然后使用自定义的类加载器, 在加载 .class的时候先对其进行解密, 然后就可以将解密后的类加载到内存中.






几种类型的类加载器

![1595643255768](1595643255768.png)



#### 线程安全

线程安全问题可以通过 synchronized 和 CAS技术 来实现

###### synchronized 

> 实际上就是使用一个对象将其标记为锁对象, 然后执行目标加锁代码, 这要求多个线程同时使用同一个对象作为锁对象
>
> 该方法的实现的思想为 悲观锁, 即我来了就把对象锁住, 其他人不能访问,我走之后别人才能访问

###### Lock

>   J.U.C 包中提供的 Lock 系列类利用悲观锁的思想能够帮助提供线程安全

###### CAS

> 实际上就是多次尝试, 每次执行完操作后都对原值进行检查, 如果检查后发现原值和实际值不相同, 那就说明在我操作的过程中别的线程对该数据进行了操作, 那么此时就重新再操作一次, 直至检查后发现原值和实际值相同, 才把操作结果返回. 
>
> 该方法的思想为 乐观锁, 即我不断尝试进行操作, 如果别人把原来的值改了, 那我就重新再做一次. 
>
> CAS是无锁的线程安全的操作, 能够提高程序运行的效率
>
> JUC 的 AtomicXXX 就是使用乐观锁的思想



